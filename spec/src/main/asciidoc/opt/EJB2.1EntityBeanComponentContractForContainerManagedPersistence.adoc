[[a384]]
== Enterprise Beans 2.1 Entity Bean Component Contract for Container-Managed Persistence

The Enterprise Beans 2.1 entity bean component contract for container-managed persistence is the contract between an entity bean and its container.
It defines the life cycle of the entity bean instances, the model for method delegation of the business methods invoked by the client, and the model for the management of the entity bean’s persistent state and relationships.
The main goal of this contract is to ensure that an entity bean component using container-managed persistence is portable across all compliant Enterprise Beans containers.

This chapter defines the Enterprise Bean Provider’s view of this contract and responsibilities of the Container Provider for managing the life cycle of the enterprise bean instances and their persistent state and relationships.

_Note that use of dependency injection, interceptors, and Java language metadata annotations is not supported for Enterprise Beans 2.1 entity beans._

=== Overview

In accordance with the architecture for container-managed persistence, the Bean Provider develops a set of entity beans for an application, and determines the relationships among them.
The Bean Provider designs an abstract persistence schema for each entity bean, which defines its container-managed fields and relationships, and determines the methods for accessing them.
The entity bean instance accesses its container-managed fields and relationships at runtime by means of the methods defined for its abstract persistence schema.

The abstract persistence schema is specified in the deployment descriptor that is produced by the Bean Provider.
The Deployer, using the Container Provider’s tools, determines how the persistent fields and relationships defined by the abstract persistence schema are mapped to a database or other persistent store, and generates the necessary additional classes and interfaces that enable the container to manage the persistent fields and relationships of the entity bean instances at runtime.

This chapter describes the component contract for an Enterprise Beans 2.1 entity bean with container-managed persistence, and how data independence is maintained between the entity bean instance and its representation in the persistent store.
It describes this contract from the viewpoints of both the Bean Provider and the container.

=== Container-Managed Entity Persistence and Data Independence

The Enterprise Beans component model provides a separation between the client view of a bean (as presented by its home and component interfaces) and the entity bean class (which provides the implementation of the client view).
The Enterprise Beans architecture for container-managed persistence adds to this a separation between the entity bean class (as defined by the Bean Provider) and its persistent representation.
The container-managed persistence architecture thus provides not only a layer of data independence between the client view of a bean as an _entity object_ and the Bean Provider’s internal view of the bean in terms of the entity bean instance, but also between the entity bean instance and its persistent representation.
This allows an entity bean to be evolved independently from its clients, without requiring the redefinition or recompilation of those clients, and it allows an entity bean to be redeployed across different containers and different persistent data stores, without requiring the redefinition or recompilation of the entity bean class.

In container-managed persistence, unlike in bean-managed persistence, the Bean Provider does not write database access calls in the methods of the entity bean class.
Instead, persistence is handled by the container at runtime. The entity Bean Provider must specify in the deployment descriptor those persistent fields and relationships for which the container must handle data access. 
The Bean Provider codes all persistent data access by using the accessor methods that are defined for the abstract persistence schema.
The implementation of the persistent fields and relationships, as well as all data access, is deferred to the container.

It is the responsibility of the Deployer to map the abstract persistence schema of a set of interrelated entity bean classes into the physical schema used by the underlying data store (e.g., into a relational schema) by using the Container Provider’s tools.
The Deployer uses the deployment descriptor as input to the Container Provider’s tools to perform this mapping.
The Container Provider’s tools are also used to generate the concrete implementation of the entity bean classes, including the code that delegates calls to the accessor methods of the entity bean class to the runtime persistent data access layer of the container.

The Enterprise Beans deployment descriptor for Enterprise Beans 2.1 entity beans describes _logical_ relationships among entity beans.
It does not provide a mechanism for specifying how the abstract persistence schema of an entity bean or of a set of interrelated entity beans is to be mapped to an underlying database.
This is the responsibility of the Deployer, who, using the Container Provider’s tools, uses the logical relationships that are specified in the deployment descriptor to map to the physical relationships that are specific to the underlying resource.
It is the responsibility of the container to manage the mapping between the logical and physical relationships at runtime and to manage the referential integrity of the relationships.

The advantage of using container-managed persistence is that the entity bean can be logically independent of the data source in which the entity is stored.
The Container Provider’s tools can, for example, generate classes that use JDBC or SQLJ to access the entity state in a relational database; classes that implement access to a non-relational data source, such as an IMS database; or classes that implement function calls to existing enterprise applications. These tools are typically specific to each data source.

.View of Underlying Data Sources Accessed Through Entity Bean
image::EBOpt-8.svg[]

=== The Entity Bean Provider’s View of Container-Managed Persistence

An entity bean implements an object view of a business entity or set of business entities stored in an underlying database or implemented by an existing enterprise application (for example, by a mainframe program or by an ERP application).

An entity bean with container-managed persistence typically consists of its entity bean class; a component interface which defines its client view business methods; a home interface which defines the create, remove, home, and finder methods of its client view; and its abstract persistence schema as specified in the deployment descriptor.

A client of an entity bean can control the life cycle of a bean by using the bean’s home interface and can manipulate the bean as a business entity by using the methods defined by its component interface.
The home and component interfaces of a bean define its client view.

An entity bean with container-managed persistence typically has container-managed relationships with other container-managed persistence entity beans, as defined by the `relationships`  element of
the deployment descriptor.
The architecture for container-managed persistence thus allows the Bean Provider to implement complex applications by defining a complex abstract persistence schema encompassing multiple entity bean classes related by means of container-managed relationships.

An entity bean accesses related entity beans by means of the accessor methods for its container-managed relationship fields, which are specified by the `cmr-field`  elements of its abstract persistence schema defined in the deployment descriptor.
Entity bean relationships are defined in terms of the local interfaces of the related beans, and the view an entity bean presents to its related beans is defined by its local home and local interfaces. Thus, an entity bean can be the target of a relationship from another entity bean only if it has a local interface.

The Bean Provider programming an application that uses container-managed persistence typically avoids calls to the methods of the remote home and remote interfaces in favor of invoking related beans by means of the methods of their local interfaces.
Unlike remote method calls, such internal method invocations are made using call-by-reference and commonly do not involve the checking of method permissions.

The Enterprise Beans architecture for container-managed persistence provides great flexibility to the Bean Provider in designing an application.

****
_For example, a group of related entity beans—`Order`, `LineItem` and `Customer`—might all be defined as having only local interfaces, with a remotable session bean containing the business logic that drives their invocation.
The individual entity beans form a coordinated whole that provides an interrelated set of services that are exposed by their several home and component interfaces.
The services provided by the local network of entity beans is exposed to the remote client view through the home and remote interfaces of the session bean, which offers a coarser grained remote service._

_Alternatively, a single entity bean might represent an independent, remotable business object that forms a unit of distribution that is designed to be referenced remotely by multiple enterprise beans and/or other remote clients.
Such a remotable entity bean might make use of other entity beans within its local scope to further model its complex internal state.
For example, an `Order` entity bean might make use of a `LineItem` entity bean internally, not exposing it to remote clients.
In this case, the `Order` entity bean might define both a remote and a local component interface, where the local interface is presented only to the related entity beans, such as `LineItem`, and the remote interface is presented to session beans and/or web-tier clients._
****

==== The Entity Bean Provider’s Programming Contract

The Bean Provider must observe the following programming contract when defining an entity bean class that uses container-managed persistence:

* The Bean Provider must define the entity bean class as an abstract class.
The container provides the implementation class that is used at runtime.

* The container-managed persistent fields and container-managed relationship fields must _not_ be defined in the entity bean class.
From the perspective of the Bean Provider, the container-managed persistent fields and container-managed relationship fields are virtual fields only, and are accessed through get and set accessor methods.
The implementation of the container-managed persistent fields and container-managed relationship fields is supplied by the container.

* The container-managed persistent fields and container-managed relationship fields must be specified in the deployment descriptor using the `cmp-field` and `cmr-field` elements respectively.
The names of these fields must be valid Java identifiers and must begin with a lowercase letter, as determined by `java.lang.Character.isLowerCase`.

* The Bean Provider must define the accessor methods for the container-managed persistent fields and container-managed relationship fields as get and set methods, using the JavaBeans conventions. The implementation of the accessor methods is supplied by the container.

* The accessor methods must be public, must be abstract, and must bear the name of the container-managed persistent field (`cmp-field`) or container-managed relationship field (`cmr-field`) that is specified in the deployment descriptor, and in which the first letter of the name of the cmp-field or cmr-field has been uppercased and prefixed by "```get```" or "```set```".

* The accessor methods for a container-managed relationship field must be defined in terms of the local interface of the related entity bean, as described in <<a437>>.

* The accessor methods for container-managed relationship fields for one-to-many or many-to-many relationships must utilize one of the following Collection interfaces: `java.util.Collection` or `java.util.Set`.
The Collection interfaces used in relationships are specified in the deployment descriptor.
The implementation of the collection classes used for the container-managed relationship fields is supplied by the container.

* An entity bean local interface type (or a collection of such) can be the type of a cmr-field. An entity bean local interface type (or a collection of such) cannot be the type of a cmp-field.

* The accessor methods for the container-managed relationship fields must not be exposed in the remote interface of an entity bean.

* The local interface types of the entity bean and of related entity beans must not be exposed through the remote interface of the entity bean.

* The collection classes that are used for container-managed relationships must not be exposed through the remote interface of the entity bean.

* Once the primary key for an entity bean has been set, the Bean Provider must not attempt to change it by use of set accessor methods on the primary key cmp-fields.
The Bean Provider should therefore not expose the set accessor methods for the primary key cmp-fields in the component interface of the entity bean.

* The Bean Provider must ensure that the Java types assigned to the cmp-fields are restricted to the following: Java primitive types and Java serializable types.

[[a437]]
==== The Entity Bean Provider’s View of Persistent Relationships

An entity bean may have relationships with other entity beans with container-managed persistence.

Relationships may be one-to-one, one-to-many, or many-to-many relationships.

Container-managed relationships can exist only among entity beans within the same local relationship scope, as defined by the `relationships` element in the deployment descriptor.
Container-managed relationships are defined in terms of the local interfaces of the related beans.

Relationships may be either bidirectional or unidirectional.
If a relationship is bidirectional, it can be navigated in both directions, whereas a unidirectional relationship can be navigated in one direction only.

A unidirectional relationship is implemented with a cmr-field on the entity bean instance from which navigation can take place, and no related cmr-field on the entity bean instance that is the target of the relationship.
Unidirectional relationships are typically used when the Bean Provider wishes to restrict the visibility of a relationship.

An entity bean that does not have a local interface can have only unidirectional relationships from itself to other entity beans.
The lack of a local interface prevents other entity beans from having a relationship to it.

The bean developer navigates or manipulates relationships by using the get and set accessor methods for the container-managed relationship fields and the `java.util.Collection` API for collection-valued container-managed
relationship fields.

The Bean Provider must consider the type and cardinality of relationships when the entity bean classes are programmed.
The get method for a cmr-field must return either the local interface of the entity bean or a collection (either `java.util.Collection` or `java.util.Set`) of the same.
The set method for the relationship must take as an argument the entity bean’s local interface or a collection of the same.

==== Dependent Value Classes

A dependent value class is a concrete class that is the value of a cmp-field.
A dependent value class may be a class that the Bean Provider wishes to use internally within an entity bean with container-managed persistence, and/or it may be a class that the Bean Provider chooses to expose through the remote (or local) interface of the entity bean.

A dependent value class can be the value of a cmp-field; it cannot be the value of a cmr-field.

The get accessor method for a cmp-field that corresponds to a dependent value class returns a _copy_ of the dependent value class instance.
The assignment of a dependent value class value to a cmp-field using the set accessor method causes the value to be copied to the target cmp-field.

A dependent value class must be serializable.
The internal structure of a dependent value class is not described in
the Enterprise Beans deployment descriptor.

==== Remove Protocols

The Bean Provider can specify the removal of an entity object in two ways:

* By the use of a `remove` method on the entity bean’s component interface or home interface.

* By the use of a `cascade-delete` specification in the deployment descriptor.

===== Remove Methods

When the `remove` method is invoked on an entity object, the container must invoke the entity Bean Provider’s `ejbRemove` method as described in <<a1279>>.
After the Bean Provider’s `ejbRemove` method returns (and prior to returning to the client), the container must remove the entity object from all relationships in which it participates, and then remove its persistent
representation.
footnote:a3368[At this point it must appear to the application that the entity has been removed from the persistent store. If the container employs an optimistic caching strategy and defers the removal of the entity from the database (e.g., to the end of transaction), this must be invisible to the application.]

* Once an entity has been removed from a relationship, the accessor methods for any relationships to the entity will reflect this removal.
An accessor method for a one-to-one or many-to-one relationship to the entity will return null; and an accessor method for a many-to-many relationship to the entity will return a collection from which the entity object has been removed.

* The container must detect any subsequent attempt to invoke an accessor method on the removed entity object and throw the `java.rmi.NoSuchObjectException` if the client is a remote client or the `jakarta.ejb.NoSuchObjectLocalException` if the client is a local client.
The container must detect an attempt to assign a removed entity object as the value of a cmr-field of another object (whether as an argument to a set accessor method or as an argument to a method of the `java.util.Collection` API) and throw the `java.lang.IllegalArgumentException`.

After removing the entity object from all relationships and removing its persistent representation, the container must then cascade the removal to all entity beans with which the entity had been previously in container-managed relationships for which the `cascade-delete` option was specified.

More than one relationship may be affected by the removal of an entity object, as in the following example.
Once the shipping address object used by the `Order` bean has been removed, the billing address accessor method will also return null.
[source, java]
----
public void changeAddress()
    Address a = createAddress();
    setShippingAddress(a);
    setBillingAddress(a);
    //both relationships now reference the same entity object
    getShippingAddress().remove();
    if (getBillingAddress() == null) // it must be
        ...
    else ...
         // this is impossible....
----

The `remove` method, alone, causes only the entity on which it is invoked to be removed.
It does not cause the deletion to be cascaded to other entity objects.
In order for the deletion of one entity object to be automatically cascaded to another, the `cascade-delete` mechanism should be used.

===== Cascade-delete

The `cascade-delete` deployment descriptor element is used within a particular relationship to specify that the lifetime of one or more entity objects is dependent upon the lifetime of another entity object.

The `cascade-delete` deployment descriptor element is contained within the `ejb-relationship-role` element.
The `cascade-delete` element can only be specified for an `ejb-relationship-role` element contained in an `ejb-relation` element if the _other_ `ejb-relationship-role` element in the same `ejb-relation` element specifies a `multiplicity` of `One`.
The `cascade-delete` option cannot be specified for a many-to-many relationship.
The deletion of one entity object can only be cascaded to cause the deletion of other entity objects if the first entity object is in a one-to-one or one-to-many relationship with those other entity objects.

If an entity is deleted, and the `cascade-delete` deployment descriptor element is specified for a related entity bean, then the removal is cascaded to cause the removal of the related entity object or objects.
As with the `remove` operation, the removal triggered by the `cascade-delete` option causes the container to invoke the `ejbRemove` method on the entity bean instance that is to be removed before the persistent representation of that entity object is removed.
Once an entity has been removed from a relationship because of a cascaded delete, the accessor methods for any relationships to the entity will reflect this removal.
An accessor method for a one-to-one or many-to-one relationship to the entity will return null; and an accessor method for a many-to-many relationship to the entity will return a collection from which the entity object has been removed.
After removing the entity object from all relationships and removing its persistent representation, the container must then cascade the removal to all entity beans with which the entity had been previously been in container-managed relationships for which the `cascade-delete` option was specified.

The use of `cascade-delete` causes only the entity object or objects in the relationship for which it is specified to be deleted.
It does not cause the deletion to be further cascaded to other entity objects, unless they are participants in relationship roles for which `cascade-delete` has also been specified.

==== Identity of Entity Objects

From the viewpoint of the Bean Provider, entity objects have a runtime object identity that is maintained by the container.

The container maintains the persistent identity of an entity object on the basis of its primary key.

The primary key of an entity bean may or may not be visible as one or more cmp-fields of the instance, depending on the way in which it is specified. The Bean Provider specifies the primary key as described in <<a1820>>.
Once it has been set, the Bean Provider must not attempt to change the value of a primary key field by means of a set method on its cmp-fields.

When a new instance of an entity bean whose primary key fields are visible in the entity bean class is created, the Bean Provider must use the `ejbCreate<METHOD>` method to set all the primary key fields of the entity bean instance before the instance can participate in a relationship, e.g. be used in a set accessor method for a cmr-field.
The Bean Provider must not reset a primary key value by means of a set method on any of its cmp-fields after it has been set in the `ejbCreate<METHOD>` method.
If the Bean Provider attempts to reset a primary key value, the container must throw the `java.lang.IllegalStateException`.

****
_Note that the container’s implementation of the referential integrity semantics for container-managed relationships must not cause the value of the primary key to change._

_The Bean Provider should not use untrimmed or blank-padded string-valued primary key fields. Use of untrimmed primary key fields may cause comparison operations based on primary keys to fail, and may result in non-portable behavior.
If untrimmed strings are used in primary key fields or other cmp-fields, the container or database system may trim them._
****

[[a496]]
==== Semantics of Assignment for Relationships

The assignment operations for container-managed relationships have a special semantics that is determined by the referential integrity semantics for the relationship multiplicity.

In the case of a one-to-one relationship, when the Bean Provider uses a set accessor method to assign an object from a cmr-field in one instance to a cmr-field of the _same relationship type_ (i.e., as defined by the `ejb-relation` and `ejb-relationship-role` deployment descriptor elements) in another instance, the object is effectively _moved_ and the value of the source cmr-field is set to null in the same transaction context.
If the argument to the set accessor method is not of the same type as the cmr-field, the container must throw the `java.lang.IllegalArgumentException`.

In the case of a one-to-many or many-to-many relationship, either the `java.util.Collection` API or a set accessor method may be used to manipulate the contents of a collection-valued cmr-field.
These two approaches are discussed below.

===== Use of the java.util.Collection API to Update Relationships

The methods of the `java.util.Collection` API for the container-managed collections used for collection-valued cmr-fields have the usual semantics, with the following exception: the `add` and `addAll` methods applied to container-managed collections in one-to-many relationships have a special semantics that is determined by the referential integrity of one-to-many relationships.

* If the argument to the `add` method is already an element of a collection-valued relationship field of the _same relationship type_ as the target collection (as defined by the `ejb-relation` and `ejb-relationship-role` deployment descriptor elements), it is removed from this first relationship and added, in the same transaction context, to the target relationship (i.e., it is effectively moved from one collection of the relationship type to the other).
For example, if there is a one-to-many relationship between field offices and sales representatives, adding a sales representative to a new field office will have the effect of removing him or her from his or her current field office.
If the argument to the `add` method is not an element of a collection-valued relationship of the _same relationship type_, it is simply added to the target collection and not removed from its current collection, if any.

* The `addAll` method, when applied to a target collection in a one-to-many relationship, has similar semantics, applied to the members of its collection argument individually.

****
_Note that in the case of many-to-many relationships, adding an element or elements to the contents of a collection-valued cmr-field has no effect on the source collection, if any.
For example, if there is a many-to-many relationship between customers and sales representatives, a customer can be added to the set of customers handled by a particular sales representative without affecting the set of customers handled by any other sales representative._
****

When the `java.util.Collection` API is used to manipulate the contents of container-managed relationship fields, the argument to any Collection method defined with a single Object parameter must be of the element type of the collection defined for the target cmr-field.
The argument for any collection-valued parameter must be a `java.util.Collection` (or `java.util.Set`), all of whose elements are of the element type of the collection defined for the target cmr-field.
If an argument is not of the correct type for the relationship, the container must throw the `java.lang.IllegalArgumentException`.

The Bean Provider should exercise caution when using an Iterator over a collection in a container-managed relationship.
In particular, the Bean Provider should not modify the container-managed collection while the iteration is in progress in any way that causes elements to be added or removed, other than by the `java.util.Iterator.remove()` method.
If elements are added or removed from the underlying container-managed collection used by an iterator other than by the `java.util.Iterator.remove()` method, the container should throw the `java.lang.IllegalStateException` on the next operation on the iterator.

The following example illustrates how operations on container-managed relationships that affect the contents of a collection-valued cmr-field viewed through an iterator can be avoided.
Because there is a one-to-many relationship between field offices and sales representatives, adding a sales representative to a new field office causes the sales representative to be removed from the current field office.
[source, java]
----
Collection nySalesreps = nyOffice.getSalesreps();
Collection sfSalesreps = sfOffice.getSalesreps();

Iterator i = nySalesreps.iterator();
Salesrep salesrep;

// a wrong way to transfer the salesrep
while (i.hasNext()) {
    salesrep = (Salesrep)i.next();
    sfSalesreps.add(salesrep); // removes salesrep from nyOffice
}

// this is a correct and safe way to transfer the salesrep
while (i.hasNext()) {
    salesrep = (Salesrep)i.next();
    i.remove();
    sfSalesreps.add(salesrep);
}
----

===== Use of Set Accessor Methods to Update Relationships

The semantics of a set accessor method, when applied to a collection-valued cmr-field, is also determined by the referential integrity semantics associated with the multiplicity of the relationship.
The identity of the collection object referenced by a cmr-field does not change when a set accessor method is executed.

In the case of a one-to-many relationship, if a collection of entity objects is assigned from a cmr-field of in one instance to a cmr-field of the same relationship type in another instance, the objects in the collection are effectively moved.
The contents of the collection of the target instance are replaced with the contents of the collection of the source instance, but the _identity_ of the collection object containing the instances in the relationship does not change.
The source cmr-field references the same collection object as before (i.e., the identity of the collection object is preserved), but the collection is empty.

The Bean Provider can thus use the set method to move objects between the collections referenced by cmr-fields of the same relationship type in different instances.
The set accessor method, when applied to a cmr-field in a one-to-many relationship thus has the semantics of the `java.util.Collection` methods `clear`, followed by `addAll`, applied to the target collection; and `clear`, applied to the source collection.
It is the responsibility of the container to transfer the contents of the collection instances in the same transaction context.

****
_Note that if the collection that is passed to the cmr setter method is an unmanaged collection (i.e., not itself the value of a collection-valued cmr-field), the same requirements apply in the case that the collection contains entity objects that already participate in a one-to-many relationship of the same relationship type as the target cmr-field._
****

In the following example, the telephone numbers associated with the billing address of an `Order` bean instance are transferred to the shipping address.
Billing address and shipping address are different instances of the same local interface type, `Address`.
`Address` is related to `TelephoneNumber` in a one-to-many relationship.
The example illustrates how a Bean Provider uses the set method to move a set of instances.
[source, java]
----
public void changeTelephoneNumber() {
    Address a = getShippingAddress();
    Address b = getBillingAddress();
    Collection c = b.getTelephoneNumbers();
    a.setTelephoneNumbers(b.getTelephoneNumbers());
    if (c.isEmpty()) { // must be true...
     ...
    }
}
----

In the case of a many-to-many relationship, if the value of a cmr-field is assigned to a cmr-field of the same relationship type in another instance, the objects in the collection of the first instance are assigned as the contents of the cmr-field of the second instance.
The identities of the collection objects referenced by the cmr-fields do not change.
The contents of the collections are shared, but not the collections themselves.
The set accessor method, when applied to a cmr-field in a many-to-many relationship thus has the semantics of the `java.util.Collection` methods `clear`, followed by `addAll`, applied to the target collection.

For example, if there is a many-to-many relationship between customers and sales representatives, assigning the set of customers of one sales representative to the another sales representative will result in both sales representatives handling the same customers.
If the second sales representative originally handled a different group of customers, those customers will no longer be handled by that sales representative.
[source, java]
----
public void shareCustomers(SalesRep rep) {
    setCustomers(rep.getCustomers());
    // the customers are shared among the sales reps
}
----

The following section, <<a558>>, defines the semantics of assignment for relationships in further detail.

[[a558]]
==== Assignment Rules for Relationships

This section defines the semantics of assignment and collection manipulation in one-to-one, one-to-many, and many-to-many container-managed relationships.

The figures make use of two entity beans, with local interface types A and B. Instances with local interface type `A` are typically designated as `a1`,...,`an`; instances with local interface type `B` are typically designated as `b1`,...,`bm`.
Interface `A` exposes accessor methods `getB` and `setB` for navigable relationships with `B`: `getB` returns an instance of `B` or a collection of instances of `B`, depending on the multiplicity of the relationship.
Similarly, `B` exposes accessor methods `getA` and `setA` for navigable relationships with `A`.

All changes in each subsection are assumed to be applied to the figure labeled "`Before change`" at the beginning of the subsection (i.e., changes are not cumulative).
The results of changes are designated graphically as well as in conditional expressions expressed in the Java(TM) programming language.

===== One-to-one Bidirectional Relationships

image::EBOpt-9.svg[]

Before change:
[source, java]
----
B b1 = a1.getB();
B b2 = a2.getB();
----

Change:
[source, java]
----
a1.setB(a2.getB());
----

Expected result:
[source, java]
----
(b2.isIdentical(a1.getB())) &&
(a2.getB() == null) &&
(b1.getA() == null) &&
(a1.isIdentical(b2.getA()))
----

image::EBOpt-10.svg[]

===== One-to-one Unidirectional Relationships

image::EBOpt-11.svg[]

Before change:
[source, java]
----
B b1 = a1.getB();
B b2 = a2.getB();
----

Change:
[source, java]
----
a1.setB(a2.getB());
----

Expected result:
[source, java]
----
(b2.isIdentical(a1.getB())) && (a2.getB() == null)
----

image::EBOpt-12.svg[]

===== One-to-many Bidirectional Relationships

image::EBOpt-13.svg[]

Before change:
[source, java]
----
Collection b1 = a1.getB();
Collection b2 = a2.getB();
B b11, b12, ... , b1n; // members of b1
B b21, b22, ... , b2m; // members of b2
----

Change:
[source, java]
----
a1.setB(a2.getB());
----

Expected result:
[source, java]
----
(a2.getB().isEmpty()) &&
(b2.isEmpty()) &&
(b1 == a1.getB()) &&
(b2 == a2.getB()) &&
(a1.getB().contains(b21)) &&
(a1.getB().contains(b22)) && ... &&
(a1.getB().contains(b2m)) &&
(b11.getA() == null) &&
(b12.getA() == null) && ... &&
(b1n.getA() == null) &&
(a1.isIdentical(b21.getA())) &&
(a1.isIdentical(b22.getA())) && ...&&
(a1.isIdentical(b2m.getA()))
----

image::EBOpt-14.svg[]

Change:
[source, java]
----
b2m.setA(b1n.getA());
----

Expected result:
[source, java]
----
(b1.contains(b11)) &&
(b1.contains(b12)) && ... &&
(b1.contains(b1n)) &&
(b1.contains(b2m)) &&
(b2.contains(b21)) &&
(b2.contains(b22)) && ... &&
(b2.contains(b2m_1)) &&
(a1.isIdentical(b11.getA())) &&
(a1.isIdentical(b12.getA())) && ... &&
(a1.isIdentical(b1n.getA())) &&
(a2.isIdentical(b21.getA())) &&
(a2.isIdentical(b22.getA())) && ... &&
(a2.isIdentical(b2m_1.getA())) &&
(a1.isIdentical(b2m.getA()))
----

image::EBOpt-15.svg[]

Change:
[source, java]
----
a1.getB().add(b2m);
----

Expected result:
[source, java]
----
(b1.contains(b11)) &&
(b1.contains(b12)) && ... &&
(b1.contains(b1n)) &&
(b1.contains(b2m)) &&
(b2.contains(b21)) &&
(b2.contains(b22)) && ... &&
(b2.contains(b2m_1)) &&
(a1.isIdentical(b11.getA())) &&
(a1.isIdentical(b12.getA())) && ... &&
(a1.isIdentical(b1n.getA())) &&
(a2.isIdentical(b21.getA())) &&
(a2.isIdentical(b22.getA())) && ... &&
(a2.isIdentical(b2m_1.getA())) &&
(a1.isIdentical(b2m.getA()))
----

image::EBOpt-16.svg[]

Change:
[source, java]
----
a1.getB().remove(b1n);
----

Expected result:
[source, java]
----
(b1n.getA() == null) &&
(b1 == a1.getB()) &&
(b1.contains(b11)) &&
(b1.contains(b12)) && ... &&
(b1.contains(b1n_1)) &&
!(b1.contains(b1n))
----

image::EBOpt-17.svg[]

===== One-to-many Unidirectional Relationships

image::EBOpt-18.svg[]

Before change:
[source, java]
----
Collection b1 = a1.getB();
Collection b2 = a2.getB();
B b11, b12, ... , b1n; // members of b1
B b21, b22, ... , b2m; // members of b2
----

Change:
[source, java]
----
a1.setB(a2.getB());
----

Expected result:
[source, java]
----
(a2.getB().isEmpty()) &&
(b2.isEmpty()) &&
(b1 == a1.getB()) &&
(b2 == a2.getB()) &&
(a1.getB().contains(b21)) &&
(a1.getB().contains(b22)) && ... &&
(a1.getB().contains(b2m))
----

image::EBOpt-19.svg[]

Change:
[source, java]
----
a1.getB().add(b2m);
----

Expected result:
[source, java]
----
(b1 == a1.getB()) &&
(b1.contains(b2m))
----

image::EBOpt-20.svg[]

Change:
[source, java]
----
a1.getB().remove(b1n);
----

Expected result:
[source, java]
----
(a1.getB().contains(b11)) &&
(a1.getB().contains(b12)) && ... &&
(a1.getB().contains(b1n_1)) &&
!(a1.getB().contains(b1n)) &&
----

image::EBOpt-21.svg[]

===== Many-to-one Unidirectional Relationships

image::EBOpt-22.svg[image]

Before change:
[source, java]
----
B b11, b12, ... , b1n;
B b21, b22, ... , b2m;
// the following is true
// (a1.isIdentical(b11.getA())) && ... && (a1.isIdentical(b1n.getA())) &&
// (a2.isIdentical(b21.getA())) && ... && (a2.isIdentical(b2m.getA()))
----

Change:
[source, java]
----
b1j.setA(b2k.getA());
----

Expected result:
[source, java]
----
(a1.isIdentical(b11.getA())) &&
(a1.isIdentical(b12.getA())) &&
...
(a2.isIdentical(b1j.getA())) &&
...
(a1.isIdentical(b1n.getA())) &&
(a2.isIdentical(b21.getA())) &&
(a2.isIdentical(b22.getA())) &&
...
(a2.isIdentical(b2k.getA())) &&
...
(a2.isIdentical(b2m.getA()))
----

image::EBOpt-23.svg[]

===== Many-to-many Bidirectional Relationships

image::EBOpt-24.svg[image]

Before change the following holds:
[source, java]
----
(a1.getB().contains(b1)) &&
(a1.getB().contains(b2)) &&
(a2.getB().contains(b1)) &&
(a2.getB().contains(b2)) &&
(a2.getB().contains(b3)) &&
(a3.getB().contains(b2)) &&
(a3.getB().contains(b3)) &&
(a3.getB().contains(b4)) &&
(a4.getB().contains(b3)) &&
(a4.getB().contains(b4)) &&
(a4.getB().contains(b5)) &&
(a5.getB().contains(b4)) &&
(a5.getB().contains(b5)) &&
(b1.getA().contains(a1)) &&
(b1.getA().contains(a2)) &&
(b2.getA().contains(a1)) &&
(b2.getA().contains(a2)) &&
(b2.getA().contains(a3)) &&
(b3.getA().contains(a2)) &&
(b3.getA().contains(a3)) &&
(b3.getA().contains(a4)) &&
(b4.getA().contains(a3)) &&
(b4.getA().contains(a4)) &&
(b4.getA().contains(a5)) &&
(b5.getA().contains(a4)) &&
(b5.getA().contains(a5)) &&
----

Change:
[source, java]
----
a1.setB(a3.getB());
----

Expected result:
[source, java]
----
(a1.getB().contains(b2)) &&
(a1.getB().contains(b3)) &&
(a1.getB().contains(b4)) &&
(a3.getB().contains(b2)) &&
(a3.getB().contains(b3)) &&
(a3.getB().contains(b4)) &&
(b1.getA().contains(a2)) &&
(b2.getA().contains(a1)) &&
(b2.getA().contains(a2)) &&
(b2.getA().contains(a3)) &&
(b3.getA().contains(a1)) &&
(b3.getA().contains(a2)) &&
(b3.getA().contains(a3)) &&
(b3.getA().contains(a4)) &&
(b4.getA().contains(a1)) &&
(b4.getA().contains(a3)) &&
(b4.getA().contains(a4)) &&
(b4.getA().contains(a5))
----

image::EBOpt-25.svg[]

Change:
[source, java]
----
a1.getB().add(b3);
----

Expected result:
[source, java]
----
(a1.getB().contains(b1)) &&
(a1.getB().contains(b2)) &&
(a1.getB().contains(b3)) &&
(b3.getA().contains(a1)) &&
(b3.getA().contains(a2)) &&
(b3.getA().contains(a3)) &&
(b3.getA().contains(a4)) &&
----

image::EBOpt-26.svg[]

Change:
[source, java]
----
a2.getB().remove(b2);
----

Expected result:
[source, java]
----
(a2.getB().contains(b1)) &&
(a2.getB().contains(b3)) &&
(b2.getA().contains(a1)) &&
(b2.getA().contains(a3))
----

image::EBOpt-27.svg[]

===== Many-to-many Unidirectional Relationships

image::EBOpt-28.svg[]

Before change the following holds:
[source, java]
----
(a1.getB().contains(b1)) &&
(a1.getB().contains(b2)) &&
(a2.getB().contains(b1)) &&
(a2.getB().contains(b2)) &&
(a2.getB().contains(b3)) &&
(a3.getB().contains(b2)) &&
(a3.getB().contains(b3)) &&
(a3.getB().contains(b4)) &&
(a4.getB().contains(b3)) &&
(a4.getB().contains(b4)) &&
(a4.getB().contains(b5)) &&
(a5.getB().contains(b4)) &&
(a5.getB().contains(b5)) &&
----

Change:
[source, java]
----
a1.setB(a3.getB());
----

Expected Result:
[source, java]
----
(a1.getB().contains(b2)) &&
(a1.getB().contains(b3)) &&
(a1.getB().contains(b4)) &&
(a3.getB().contains(b2)) &&
(a3.getB().contains(b3)) &&
(a3.getB().contains(b4)) &&
----

image::EBOpt-29.svg[]

Change:
[source, java]
----
a1.getB().add(b3);
----

Expected result:
[source, java]
----
(a1.getB().contains(b1)) &&
(a1.getB().contains(b2)) &&
(a1.getB().contains(b3))
----

image::EBOpt-30.svg[]

Change:
[source, java]
----
a2.getB().remove(b2);
----

Expected result:
[source, java]
----
(a2.getB().contains(b1)) &&
(a2.getB().contains(b3))
----

image::EBOpt-31.svg[]

==== Collections Managed by the Container

The collections that are used in the representation of one-to-many and many-to-many container-managed relationships are implemented and managed by the container.
The following semantics apply to these collections:

* It is the responsibility of the container to preserve the runtime identity of the collection objects used in container-managed relationships.

* There is no constructor available to the Bean Provider for the container-managed collections.

* If there are no related values for a given container-managed relationship, the get accessor method for that cmr-field returns an empty collection (and not `null`).

* It is the responsibility of the container to raise the `java.lang.IllegalArgumentException` if the Bean Provider attempts to assign `null` as the value of a collection-valued cmr-field by means of the set accessor method.

* It is the responsibility of the container to ensure that when the `java.util.Collection` API is used to manipulate the contents of container-managed relationship fields, the argument to any Collection method defined with a single Object parameter must be of the element type of the collection defined for the target cmr-field.
The argument for any collection-valued parameter must be a `java.util.Collection` (or `java.util.Set`), all of whose elements are of the element type of the collection defined for the target cmr-field.
If an argument is not of the correct type for the relationship, the container must throw the `java.lang.IllegalArgumentException`.

* It is the responsibility of the container to throw the `java.lang.IllegalStateException` if an attempt is made to modify a container-managed collection corresponding to a multivalued cmr-field using the `java.util.Collection` API outside of the transaction context in which the collection object was initially materialized.

* It is the responsibility of the container to throw the `java.lang.IllegalStateException` if an attempt is made to use a `java.util.Iterator` for a container-managed collection in a transaction context other than that in which the iterator was obtained.

==== Non-persistent State

The Bean Provider may use instance variables in the entity bean instance to maintain non-persistent state, e.g. a Jakarta Messaging connection.

The Bean Provider can use instance variables to store values that depend on the persistent state of the entity bean instance, although this use is not encouraged. The Bean Provider should use the `ejbLoad` method to resynchronize the values of any instance variables that depend on the entity bean’s persistent state.
In general, any non-persistent state that depends on the persistent state of an entity bean should be recomputed during the `ejbLoad` method.

The Bean Provider should exercise care in passing the contents of instance variables as the arguments or results of method invocations when local interfaces are used.
In general, the Bean Provider should avoid passing state that is maintained in instance variables as the argument or result of a local method invocation.

==== The Relationship Between the Internal View and the Client View

In designing the entity bean, the Bean Provider should keep in mind the following:

* The classes that are exposed by the remote interface are decoupled from the persistence layer.
Instances of these classes are passed to and from the client by value.

* The classes that are exposed by the local interface of the bean may be tightly coupled to the bean’s internal state.
Instances of these classes are passed to and from the client by reference and may therefore be modified by the client.
The Bean Provider should exercise care in determining what is exposed through the local interface of the bean.

===== Restrictions on Remote Interfaces

The following restrictions apply to the remote interface of an entity bean with container-managed persistence.

* The Bean Provider must not expose the get and set methods for container-managed relationship fields or the persistent `Collection` classes that are used in container-managed relationships through the remote interface of the bean.

* The Bean Provider must not expose local interface types or local home interface types through the remote interface or remote home interface of the bean.

* The Bean Provider must not expose the container-managed collection classes that are used for relationships through the remote interface of the bean.

* The Bean Provider must not expose timers or timer handles through the remote interface of the bean.

Dependent value classes can be exposed in the remote interface or remote home interface and can be included in the client ejb-jar file.

The Bean Provider is free to expose get and set methods that correspond to cmp-fields of the entity bean through the bean’s remote interface.

==== Mapping Data to a Persistent Store

This specification does not prescribe how the abstract persistence schema of an entity bean should be mapped to a relational (or other) schema of a persistent store, or define how such a mapping is described.

==== Example

<<a861>> illustrates an `Order` entity bean with relationships to line items and customers, which are other entity beans within the same local scope.
`Product` is indirectly related to `Order` by means of the
relationship between `LineItem` and `Product`.
Sample code for the `OrderBean` class follows the figure.

[[a861]]
.Relationship Example
image::EBOpt-32.svg[]

[source, java]
----
package com.acme.order;

// This example shows the implementation of OrderBean, the
// entity bean class for the OrderEJB entity bean. OrderEJB has
// container-managed relationships with the entity beans
// CustomerEJB and LineItemEJB.
// This example illustrates the use of local interfaces.

import java.util.Collection;
import java.util.Vector;
import java.util.Date;
import javax.naming.*;

public abstract class OrderBean implements jakarta.ejb.EntityBean {

    private jakarta.ejb.EntityContext context;

    // define status codes for processing

    static final int BACKORDER = 1;
    static final int SHIPPED = 2;
    static final int UNSHIPPED = 3;

    // get and set methods for the cmp fields

    public abstract int getOrderStatus();
    public abstract void setOrderStatus(int orderStatus);

    public abstract boolean getCreditApproved();
    public abstract void setCreditApproved(boolean creditapproved);

    public abstract Date getOrderDate();
    public abstract void setOrderDate(Date orderDate);

    // get and set methods for the relationship fields

    public abstract Collection getLineItems();
    public abstract void setLineItems(Collection lineitems);

    public abstract Customer getCustomer();
    public abstract void setCustomer(Customer customer);

    // business methods.

    // addLineItem:
    // This method is used to add a line item.
    // It creates the lineitem object and adds it to the
    // persistent managed relationship.

    public void addLineItem(Product product,
                 int quantity,
                 Address address)
     throws InsufficientInfoException 
    {
        // create a new line item
        if (validAddress(address)) {
            // Address is a legacy class. It is a dependent value
            // class that is available both in the client and in
            // the entity bean, and is serializable.
            // We will use the address as the value of a cmp field
            // of lineItem.
            try {
                Context ic = new InitialContext();
                LineItemLocalHome litemLocalHome =
                    (LineItemLocalHome)ic.lookup("LineItemEJB");
                LineItem litem = litemLocalHome.create();

                litem.setProduct(product);
                litem.setQuantity(quantity);
                litem.setTax(calculateTax(product.getPrice(),
                                          quantity,
                                          address));
                litem.setStatus(UNSHIPPED);
                // set the address for the line item to be shipped
                litem.setAddress(address);
                // The lineItem entity bean uses a dependent value
                // class to represent the dates for the order status.
                // This class holds shipment date, expected shipment
                // date, credit approval date, and inventory
                // dates which are internal to the order fullfillment
                // process. Not all this information will be available
                // to the client.
                Dates dates = new Dates();
                litem.setDates(dates);
                getLineItems().add(litem);
            } catch (Exception someexception) {}
        } else {
            throw new InsufficientInfoException();
        }
    }

    // getOrderLineItems:
    // This method makes a view of the lineitems that are in this
    // order available in the client. It makes only the relevant
    // information visible to the client and hides the internal
    // details of the representation of the lineitem
    public Collection getOrderLineItems() {
        Vector clientlineitems = new Vector();
        Collection lineitems = getLineItems();
        java.util.Iterator iterator = lineitems.iterator();
        // ClientLineItem is a value class that is used in
        // the client view.
        // The entity Bean Provider abstracts from the persistent
        // representation of the line item to construct the client
        // view.
        ClientLineItem clitem;
        while (iterator.hasNext()) {
            LineItem litem = (LineItem)iterator.next();
            clitem = new ClientLineItem();
            // only the name of the product is available in the
            // client view
            clitem.setProductName(litem.getProduct().getName());
            clitem.setQuantity(litem.getQuantity());
            // the client view gets a specific descriptive message
            // depending on the line item status.
            clitem.setCurrentStatus(
            statusCodeToString(litem.getStatus()));
            // address is not copied to the client view.
            // as this class includes other information with
            // respect to the order handing that should not be
            // available to the client. Only the relevant info
            // is copied.
            int lineitemStatus = litem.getStatus();
            if (lineitemStatus == BACKORDER) {
                clitem.setShipDate(
                    litem.getDates().getExpectedShipDate());
            } else if (lineitemStatus == SHIPPED) {
                clitem.setShipDate(
                    litem.getDates().getShippedDate());
            }
            //add the new line item
            clientlineitems.add(clitem);
        }
        // return the value objects to the client
        return clientlineitems;
    }
    // other methods internal to the entity bean class
    ...
    // other jakarta.ejb.EntityBean methods
    ...
}
----

[[a1013]]
==== The Bean Provider’s View of the Deployment Descriptor

The persistent fields (cmp-fields) and relationships (cmr-fields) of an entity bean must be declared in the deployment descriptor.

The deployment descriptor provides the following information about the abstract persistence schemas of entity beans and their container-managed relationships:

* An `ejb-name` element for each entity bean.
The `ejb-name` must be a valid Java identifier and must be unique within the `ejb-name` elements of the ejb-jar file.

* An `abstract-schema-name` element for each
entity bean.
The `abstract-schema-name` must be a valid Java identifier
and must be unique within the `abstract-schema-name` elements of the
ejb-jar file.
The `abstract-schema-name` element is used in the specification of Enterprise Beans QL queries.

* A set of `ejb-relation` elements, each of which contains a pair of `ejb-relationship-role` elements to describe the two roles in the relationship.
footnote:a3369[The relation names and the relationship role names are not used in the code provided by the Bean Provider.]

* Each `ejb-relationship-role` element describes a relationship role: its name, its multiplicity within a relation, and its navigability.
It specifies the name of the `cmr-field` that is used from the perspective of the relationship participant.
The `cmr-field-type` element must be specified if the type of the cmr-field
is `java.util.Collection` or `java.util.Set`.
Each relationship role refers to an entity bean by means of an ejb-name element contained in the `relationship-role-source` element.

The following example shows a deployment descriptor segment that defines the abstract persistence schema for a set of related entity beans.
The deployment descriptor elements for container-managed persistence and relationships are described further in <<a3273>>.
[source, xml]
----
<ejb-jar>
    ...
    <enterprise-beans>
    ...
    </enterprise-beans>
    <relationships>
        <!-- 
        ONE-TO-MANY: Order LineItem 
        -->
        <ejb-relation>
            <ejb-relation-name>Order-LineItem</ejb-relation-name>
            <ejb-relationship-role>
                <ejb-relationship-role-name>
                    order-has-lineitems
                </ejb-relationship-role-name>
                <multiplicity>One</multiplicity>
                <relationship-role-source>
                    <ejb-name>OrderEJB</ejb-name>
                </relationship-role-source>
                <cmr-field>
                    <cmr-field-name>lineItems</cmr-field-name>
                    <cmr-field-type>java.util.Collection
                    </cmr-field-type>
                </cmr-field>
            </ejb-relationship-role>
            <ejb-relationship-role>
                <ejb-relationship-role-name>
                    lineitem-belongsto-order
                </ejb-relationship-role-name>
                <multiplicity>Many</multiplicity>
                <cascade-delete/>
                <relationship-role-source>
                    <ejb-name>LineItemEJB</ejb-name>
                </relationship-role-source>
                <cmr-field>
                    <cmr-field-name>order</cmr-field-name>
                </cmr-field>
            </ejb-relationship-role>
        </ejb-relation>
        <!-- 
        ONE-TO-MANY unidirectional relationship:
        Product is not aware of its relationship with LineItem
        -->
        <ejb-relation>
            <ejb-relation-name>Product-LineItem</ejb-relation-name>
            <ejb-relationship-role>
                <ejb-relationship-role-name>
                    product-has-lineitems
                </ejb-relationship-role-name>
                <multiplicity>One</multiplicity>
                <relationship-role-source>
                    <ejb-name>ProductEJB</ejb-name>
                </relationship-role-source>
                <!-- since Product does not know about LineItem
                there is no cmr field in Product for accessing
                Lineitem
                -->
            </ejb-relationship-role>
            <ejb-relationship-role>
                <ejb-relationship-role-name>
                    lineitem-for-product
                </ejb-relationship-role-name>
                <multiplicity>Many</multiplicity>
                <relationship-role-source>
                    <ejb-name>LineItemEJB</ejb-name>
                </relationship-role-source>
                <cmr-field>
                    <cmr-field-name>product</cmr-field-name>
                </cmr-field>
            </ejb-relationship-role>
        </ejb-relation>
        <!--
        ONE-TO-MANY: Order Customer:
        -->
        <ejb-relation>
            <ejb-relation-name>Order-Customer</ejb-relation-name>
            <ejb-relationship-role>
                <ejb-relationship-role-name>
                    customer-has-orders
                </ejb-relationship-role-name>
                <multiplicity>One</multiplicity>
                <relationship-role-source>
                    <ejb-name>CustomerEJB</ejb-name>
                </relationship-role-source>
                <cmr-field>
                    <cmr-field-name>orders</cmr-field-name>
                    <cmr-field-type>java.util.Collection
                    </cmr-field-type>
                </cmr-field>
            </ejb-relationship-role>
            <ejb-relationship-role>
                <ejb-relationship-role-name>
                    order-belongsto-customer
                </ejb-relationship-role-name>
                <multiplicity>Many</multiplicity>
                <relationship-role-source>
                    <ejb-name>OrderEJB</ejb-name>
                </relationship-role-source>
                <cmr-field>
                    <cmr-field-name>customer</cmr-field-name>
                </cmr-field>
            </ejb-relationship-role>
        </ejb-relation>
    </relationships>
    ...
</ejb-jar>
----

=== The Entity Bean Component Contract

This section specifies the container-managed persistence contract between an entity bean and its container.

==== Runtime Execution Model of Entity Beans

This subsection describes the runtime model and the classes used in the description of the contract between an entity bean and its container.
<<a1155>> shows an overview of the runtime model.
The client of an entity bean may be a local client or it may be a remote client.

[[a1155]]
.Overview of the Entity Bean Runtime Execution Model
image::EBOpt-33.svg[]

An enterprise bean is an object whose class is provided by the Bean Provider.
The class of an entity bean with container-managed persistence is abstract.
The concrete bean class is generated by the Container Provider’s tools at deployment time.
The container is also responsible for providing the implementation of the `java.util.Collection` classes that are used in maintaining the container-managed relationships of the entity bean.

An entity *EJBObject* or *EJBLocalObject* is an object whose class was generated at deployment time by the Container Provider’s tools.
A client never references an entity bean instance directly—a client always references an entity EJBObject or EJBLocalObject whose class is generated by the Container Provider’s tools.
The entity EJBObject class implements an entity bean’s remote interface. 
The entity EJBLocalObject class implements an entity bean’s local interface.
A related entity bean never references another entity bean instance directly—a related entity bean, like any other local client of an entity bean, always references an entity EJBLocalObject whose class is generated by the Container Provider’s tools.

An entity *EJBHome* or *EJBLocalHome* object provides life cycle operations (create, find, remove) for its entity objects as well as home business methods, which are business methods that are not specific to an entity bean instance.
The class for the entity EJBHome or EJBLocalHome object is generated by the Container Provider’s tools at deployment time.
The entity EJBHome or EJBLocalHome object implements the entity bean’s remote or local home interface that was defined by the Bean Provider.

==== Container Responsibilities

The following are the container responsibilities for the management of persistent state.

===== Container-Managed Fields

An entity bean with container-managed persistence relies on the container to perform persistent data access on behalf of the entity bean instances.
The container transfers data between an entity bean instance and the underlying resource manager.
The container also implements the creation, removal, and lookup of the entity object in the underlying database.

The container transfers data between the entity bean and the underlying data source as a result of the execution of the entity bean’s methods.
Because of the requirement that all data access occur through the accessor methods, the container can implement both eager and lazy loading and storing schemes.

The container is responsible for implementing the entity bean class by providing the implementation of the get and set accessor methods for its abstract persistence schema.
The container is allowed to use Java serialization to store the container-managed persistent fields (cmp-fields).

The container must also manage the mapping between primary keys and EJBLocalObjects or EJBObjects.
If both a remote and a local interface are specified for the entity bean, the container must manage the mapping between EJBObjects and EJBLocalObjects.

****
_Because the container is free to optimize the delivery of persistent data to the bean instance (for example, by the use of lazy loading strategies), the contents of the entity bean instance and the contents of container-managed collections may not be fully materialized._
****

===== Container-Managed Relationships

The container maintains the relationships among entity beans.

* It is the responsibility of the container to maintain the referential integrity of the container-managed relationships, as described in <<a496>>, in accordance with the semantics of the relationship type as specified in the deployment descriptor.
For example, if an entity bean is added to a collection corresponding to the container-managed relationship field of another entity bean, the container-managed relationship field of the first entity bean must also be updated by the container in the same transaction context.

* It is the responsibility of the container to throw the `java.lang.IllegalArgumentException` when the argument to a set method in a relationship is an instance of the wrong relationship type or a collection containing instances of the wrong type, or when an argument to a method of the `java.util.Collection` API used to manipulate a collection-valued container-managed relationship field is an instance of the wrong type or a collection that contains instances of the wrong type (see <<a496>>).

* It is the responsibility of the container to throw the `java.lang.IllegalStateException` when a method of the `java.util.Collection` API is used to access a collection-valued cmr-field within a transaction context other than the transaction context in which the cmr-field was initially materialized.
For example, if the container-managed collection is returned as the result of a local interface method with transaction attribute `RequiresNew`, and the client attempts to access the collection, the container must throw the `IllegalStateException`.

* It is the responsibility of the container to throw the `java.lang.IllegalStateException` when a `java.util.Iterator` is used to access a collection-valued cmr-field within a transaction context other than the transaction context in which the iterator was initially obtained.

=== Instance Life Cycle Contract Between the Bean and the Container

This section describes the part of the component contract between the entity bean and the container that relates to the management of the entity bean instance’s life cycle.

==== Instance Life Cycle

[[a1191]]
.Life Cycle of an Entity Bean Instance.
image::EBOpt-34.svg[]

An entity bean instance is in one of the following three states:

* It does not exist.

* Pooled state.
An instance in the pooled state is not associated with any particular entity object identity.

* Ready state.
An instance in the ready state is assigned an entity object identity.

The following steps describe the life cycle of an entity bean instance:

* An entity bean instance’s life starts when the container creates the instance using newInstance.
The container then invokes the setEntityContext method to pass the instance a reference to the `EntityContext` interface.
The `EntityContext` interface allows the instance to invoke services provided by the container and to obtain the information about the caller of a client-invoked method.

* The instance enters the pool of available instances.
Each entity bean has its own pool.
While the instance is in the available pool, the instance is not associated with any particular entity object identity.
All instances in the pool are considered equivalent, and therefore any instance can be assigned by the container to any entity object identity at the transition to the ready state.
While the instance is in the pooled state, the container may use the instance to execute any of the entity bean’s finder methods (shown as `ejbFind<METHOD>` in the diagram) or any of the entity bean’s home methods (shown `ejbHome<METHOD>` in the diagram).
The instance does _not_ move to the ready state during the execution of a finder or a home method.
An `ejbSelect<METHOD>` method may be called by an entity bean’s home method while the instance is in the pooled state.

* An instance transitions from the pooled state to the ready state when the container selects that instance to service a client call to an entity object or an `ejbTimeout`
method.
There are two possible transitions from the pooled to the ready state: through the `ejbCreate<METHOD>` and `ejbPostCreate<METHOD>` methods, or through the `ejbActivate` method.
The container invokes the `ejbCreate<METHOD>` and `ejbPostCreate<METHOD>` methods when the instance is assigned to an entity object during entity object creation (i.e., when the client invokes a create method on the entity bean’s home object).
The container invokes the `ejbActivate` method on an instance when an instance needs to be activated to service an invocation on an existing entity object—this occurs because there is no suitable instance in the ready state to service the client’s call or the `ejbTimeout` method.

* When an entity bean instance is in the ready state, the instance is associated with a specific entity object identity.
While the instance is in the ready state, the container can synchronize the state of the instance with the state of the entity in the underlying data source whenever it determines the need to, in the process invoking the `ejbLoad` and `ejbStore` methods zero or more times.
A business method can be invoked on the instance zero or more times.
The `ejbTimeout` method can be invoked on the instance zero or more times.
Invocations of the `ejbLoad` and `ejbStore` methods can be arbitrarily mixed with invocations of business methods and `ejbTimeout` method invocations.
An `ejbSelect<METHOD>` method can be called by a business method (or `ejbLoad` or `ejbStore` method or `ejbTimeout`
method) while the instance is in the ready state.

* The container can choose to passivate an entity bean instance within a
transaction.
To passivate an instance, the container first invokes the `ejbStore` method to allow the instance to prepare itself for the synchronization of the database state with the instance’s state, and then the container invokes the `ejbPassivate` method to return the instance to the pooled state.

* Eventually, the container will transition the instance to the pooled state.
There are three possible transitions from the ready to the pooled state: through the `ejbPassivate` method, through the `ejbRemove` method, and because of a transaction rollback for `ejbCreate`, `ejbPostCreate`, or
`ejbRemove` (not shown in <<a1191>>).
The container invokes the `ejbPassivate` method when the container wants to disassociate the instance from the entity object identity without removing the entity object.
The container invokes the `ejbRemove` method when the container is removing the entity object (i.e., when the client invoked the `remove` method on the entity object’s component interface or a `remove` method on the entity bean’s home interface).
If `ejbCreate`, `ejbPostCreate`, or `ejbRemove` is called and the transaction rolls back, the container will transition the bean instance to the pooled state.

* When the instance is put back into the pool, it is no longer associated with an entity object identity.
The container can assign the instance to any entity object within the same entity bean home.

* The container can remove an instance in the pool by calling the `unsetEntityContext` method on the instance.

Notes:

. The `EntityContext` interface passed by the container to the instance in the `setEntityContext` method is an interface, not a class that contains static information.
For example, the result of the `EntityContext.getPrimaryKey` method might be different each time an instance moves from the pooled state to the ready state, and the result of the `getCallerPrincipal` and `isCallerInRole` methods may be different in each business method.

. A `RuntimeException` thrown from any method of an entity bean class (including the business methods and the callbacks invoked by the container) results in the transition to the "`does not exist`" state.
The container must not invoke any method on the instance after a `RuntimeException` has been caught.
From the caller’s perspective, the corresponding entity object continues to exist.
The client can continue accessing the entity object through its component interface because the container can use a different entity bean instance to delegate the client’s requests.
Exception handling is described further in <<a3210>>.

. The container is not required to maintain a pool of instances in the pooled state.
The pooling approach is an example of a possible implementation, but it is not the required implementation.
Whether the container uses a pool orcnot has no bearing on the entity bean coding style.

==== Bean Provider’s Entity Bean Instance’s View

The following describes the entity bean instance’s view of the contract as seen by the Bean Provider:

The entity Bean Provider is responsible for implementing the following methods in the abstract entity bean class:

* A public constructor that takes no arguments.

* `public void setEntityContext(EntityContext ic);`
+
A container uses this method to pass a reference to the `EntityContext` interface to the entity bean instance.
If the entity bean instance needs to use the `EntityContext` interface during its lifetime, it must remember the `EntityContext` interface in an instance variable.
+
This method executes with an unspecified transaction context (Refer to Enterprise Beans Core Contracts and Requirements document <<a3339>> Subsection "`Handling
of Methods that Run with an unspecified transaction context`" for how the
container executes methods with an unspecified transaction context).
An identity of an entity object is not available during this method.
The entity bean must not attempt to access its persistent state and relationships using the accessor methods during this method.
+
The instance can take advantage of the `setEntityContext()` method to allocate any resources that are to be held by the instance for its lifetime.
Such resources cannot be specific to an entity object identity because the instance might be reused during its lifetime to serve multiple entity object identities.

* `public void unsetEntityContext();`
+
A container invokes this method before terminating the life of the instance.
+
This method executes with an unspecified transaction context.
An identity of an entity object is not available during this method.
The entity bean must not attempt to access its persistent state and relationships using the accessor methods during this method.
+
The instance can take advantage of the `unsetEntityContext` method to free any resources that are held by the instance.
(These resources typically had been allocated by the `setEntityContext` method.)

* `public PrimaryKeyClass ejbCreate<METHOD>(...);`
+
There are zero
footnote:a3370[An entity bean has no `ejbCreate<METHOD>` and `ejbPostCreate<METHOD>` methods if it does not define any create methods in its home interface.
Such an entity bean does not allow its clients to create new Enterprise Beans objects.
The entity bean restricts the clients to accessing entities that were created through direct database inserts.]
or more `ejbCreate<METHOD>` methods, whose signatures match the signatures of the create<METHOD> methods of the entity bean’s home interface. The container invokes an `ejbCreate<METHOD>` method on an entity bean instance when a client invokes a matching create<METHOD> method on the entity bean’s home interface.
+
The entity Bean Provider’s responsibility is to initialize the instance in the `ejbCreate<METHOD>` methods from the input arguments, using the get and set accessor methods, such that when the `ejbCreate<METHOD>` method returns, the persistent representation of the instance can be created.
The entity Bean Provider is guaranteed that the values that will be initially returned by the instance’s get methods for container-managed fields will be the Java language defaults (e.g. 0 for integer, `null` for pointers), except for collection-valued cmr-fields, which will have the empty collection (or set) as their value.
The entity Bean Provider must not attempt to modify the values of cmr-fields in an `ejbCreate<METHOD>` method.
This should be done in the `ejbPostCreate<METHOD>` method instead.
+
The entity object created by the `ejbCreate<METHOD>` method must have a unique primary key.
This means that the primary key must be different from the primary keys of all the existing entity objects within the same home.
However, it is legal to reuse the primary key of a previously removed entity object.
The implementation of the Bean Provider’s `ejbCreate<METHOD>` methods should be coded to return a null.
footnote:a3371[The above requirement is to allow the creation of an entity bean with bean-managed persistence by subclassing an entity bean with container-managed persistence.]
+
An `ejbCreate<METHOD>` method executes in the transaction context determined by the transaction attribute of the matching `create<METHOD>` method.
The database insert operations are performed by the container within the same transaction context after the Bean Provider’s `ejbCreate<METHOD>` method completes.

* `public void ejbPostCreate<METHOD>(...);`
+
For each `ejbCreate<METHOD>` method, there is a matching `ejbPostCreate<METHOD>` method that has the same input parameters but whose return type is `void`.
The container invokes the matching `ejbPostCreate<METHOD>` method on an instance after it invokes the `ejbCreate<METHOD>` method with the same arguments.
The instance can discover the primary key by calling `getPrimaryKey` on its entity context object.
+
The entity object identity is available during the `ejbPostCreate<METHOD>` method.
The instance may, for example, obtain the component interface of the associated entity object and pass it to another enterprise bean as a method argument.
+
The entity Bean Provider may use the `ejbPostCreate<METHOD>` to set the values of cmr-fields to complete the initialization of the entity bean instance.
+
An `ejbPostCreate<METHOD>` method executes in the same transaction context as the previous `ejbCreate<METHOD>` method.

* `public void ejbActivate();`
+
The container invokes this method on the instance when the container picks the instance from the pool and assigns it to a specific entity object
identity.
The `ejbActivate` method gives the entity bean instance the chance to acquire additional resources that it needs while it is in the ready state.
+
This method executes with an unspecified transaction context.
The entity bean must not attempt to access its persistent state or relationships using the accessor methods during this method.
+
The instance can obtain the identity of the entity object via the `getPrimaryKey`, `getEJBLocalObject`, or `getEJBObject` method on the entity context.
The instance can rely on the fact that the primary key and entity object identity will remain associated with the instance until the completion of `ejbPassivate` or `ejbRemove`.

* `public void ejbPassivate();`
+
The container invokes this method on an instance when the container decides to disassociate the instance from an entity object identity, and to put the instance back into the pool of available instances.
The `ejbPassivate` method gives the instance the chance to release any resources that should not be held while the instance is in the pool.
(These resources typically had been allocated during the `ejbActivate` method.)
+
This method executes with an unspecified transaction context.
The entity bean must not attempt to access its persistent state or relationships using the accessor methods during this method.
+
The instance can still obtain the identity of the entity object via the `getPrimaryKey`, `getEJBLocalObject`, or `getEJBObject` method of the EntityContext interface.

* `public void ejbRemove();`
+
The container invokes the `ejbRemove` method on an entity bean instance in response to a client-invoked `remove` operation on the entity bean’s home or component interface or as the result of a cascade-delete operation.
The instance is in the ready state when `ejbRemove` is invoked and it will be entered into the pool when the method completes.
+
The entity Bean Provider can use the `ejbRemove` method to implement any actions that must be done before the entity object’s persistent representation is removed.
+
The container synchronizes the instance’s state before it invokes the `ejbRemove` method.
This means that the state of the instance at the beginning of the `ejbRemove` method is the same as it would be at the beginning of a business method.
+
This method and the database delete operation(s) execute in the transaction context determined by the transaction attribute of the remove method that triggered the `ejbRemove` method.
The instance can still obtain the identity of the entity object via the `getPrimaryKey`, `getEJBLocalObject`, or `getEJBObject` method of the `EntityContext` interface.
+
After the entity Bean Provider’s `ejbRemove` returns, and in the same transaction context, the container removes the entity bean from all relationships in which it participates before removing the entity object’s persistent representation.
+
Since the instance will be entered into the pool, the state of the instance at the end of this method must be equivalent to the state of a passivated instance.
This means that the instance must release any resource that it would normally release in the `ejbPassivate` method.

* `public void ejbLoad();`
+
When the container needs to synchronize the state of an enterprise bean instance with the entity object’s persistent state, the container calls the `ejbLoad` method.
+
The entity Bean Provider can assume that the instance’s persistent state has been loaded just before the `ejbLoad` method is invoked.
It is the responsibility of the Bean Provider to use the `ejbLoad` method to recompute or initialize the values of any instance variables that depend on the entity bean’s persistent state.
In general, any transient state that depends on the persistent state of an entity bean should be recalculated using the `ejbLoad` method.
The entity bean can use the `ejbLoad` method, for instance, to perform some computation on the values returned by the accessor methods (for example, uncompressing text fields).
+
This method executes in the transaction context determined by the transaction attribute of the business method or `ejbTimeout` method that triggered the `ejbLoad` method.

* `public void ejbStore();`
+
When the container needs to synchronize the state of the entity object’s persistent state with the state of the enterprise bean instance, the container first calls the `ejbStore` method on the instance.
+
The entity Bean Provider should use the `ejbStore` method to update the instance using the accessor methods before its persistent state is synchronized.
For example, the `ejbStore` method may perform compression of text before the text is stored in the database.
+
The Bean Provider can assume that after the `ejbStore` method returns, the persistent state of the instance is synchronized.
+
This method executes in the same transaction context as the previous `ejbLoad` or `ejbCreate` method invoked on the instance.
All business methods or the `ejbTimeout` method invoked between the previous `ejbLoad` or `ejbCreate<METHOD>` method and this `ejbStore` method are also invoked in the same transaction context.

* `public` _<primary key type or collection>_ `ejbFind<METHOD>(...);`
+
The Bean Provider of an entity bean with container-managed persistence does not write the finder (`ejbFind<METHOD>`) methods.
+
The finder methods are generated at the entity bean deployment time using the Container Provider’s tools.
The syntax for the Bean Provider’s specification of finder methods is described in <<a1840>>.

* `public` _<type>_ `ejbHome<METHOD>(...);`
+
The container invokes this method on the instance when the container selects the instance to execute a matching client-invoked <METHOD> home method.
The instance is in the pooled state (i.e., it is not assigned to any particular entity object identity) when the container selects the instance to execute the `ejbHome<METHOD>` method on it, and it is returned to the pooled state when the execution of the `ejbHome<METHOD>` method completes.
+
The `ejbHome<METHOD>` method executes in the transaction context determined by the transaction attribute of the matching `<METHOD>` home method, as described in Enterprise Beans Core Contracts and
Requirements document <<a3339>> Subsection "`Container-Managed Transaction Demarcation for Business Methods`".
+
The entity Bean Provider provides the implementation of the `ejbHome<METHOD>` method.
The entity bean must not attempt to access its persistent state or relationships using the accessor methods during this method because a home method is not specific to a particular bean instance.

* `public abstract` _<type>_ `ejbSelect<METHOD>(...);`
+
The Bean Provider may provide zero or more select methods.
A select method is a query method that is not directly exposed to the client in the home or component interface.
The Bean Provider typically calls a select method within a business method.
+
The Bean Provider defines the select methods as `abstract` methods.
+
The select methods are generated at the entity bean deployment time using the Container Provider’s tools.
+
The syntax for the specification of select methods is described in <<a1840>>.
+
The `ejbSelect<METHOD>` method executes in the transaction context determined by the transaction attribute of the invoking business method.

* `public void ejbTimeout(...);`
+
The container invokes the `ejbTimeout` method on an instance when a timer for the instance has expired.
The `ejbTimeout` method notifies the instance of the time-based event and
allows the instance to execute the business logic to handle it.
+
The `ejbTimeout` method executes in the transaction context determined by its transaction attribute.

[[a1279]]
==== Container’s View

This subsection describes the container’s view of the state management contract.
The container must call the following methods:

* `public void setEntityContext(ec);`
+
The container invokes this method to pass a reference to the `EntityContext` interface to the entity bean instance.
The container must invoke this method after it creates the instance, and before it puts the instance into the pool of available instances.
+
The container invokes this method with an unspecified transaction context.
At this point, the `EntityContext` is not associated with any entity object identity.

* `public void unsetEntityContext();`
+
The container invokes this method when the container wants to reduce the number of instances in the pool.
After this method completes, the container must not reuse this instance.
+
The container invokes this method with an unspecified transaction context.

* `public _PrimaryKeyClass_ ejbCreate<METHOD>(...);` +
`public void ejbPostCreate<METHOD>(...);`
+
The container invokes these two methods during the creation of an entity object as a result of a client invoking a `create<METHOD>` method on the entity bean’s home interface.
+
The container invokes the `ejbCreate<METHOD>` method whose signature matches the `create<METHOD>` method invoked by the client.
+
Prior to invoking the `ejbCreate<METHOD>` method provided by the Bean Provider, the container must ensure that the values that will be initially returned by the instance’s get methods for container-managed fields will be the Java language defaults (e.g. 0 for integer, `null` for pointers), except for collection-valued cmr-fields, which must have the empty collection (or set) as their value.
+
The container is responsible for calling the `ejbCreate<METHOD>` method, for obtaining the primary key fields of the newly created entity object persistent representation, and for creating an entity EJBObject reference and/or EJBLocalObject reference for the newly created entity object. The container must establish the primary key before it invokes the `ejbPostCreate<METHOD>` method.
+
The entity object created by the `ejbCreate<METHOD>` method must have a unique primary key.
This means that the primary key must be different from the primary keys of all the existing entity objects within the same home.
However, it is legal to reuse the primary key of a previously removed entity object.
The container may, but is not required to, throw the `DuplicateKeyException` on the Bean Provider’s attempt to create an entity object with a duplicate primary key.
footnote:a3372[Containers using optimistic caching strategies, for example, may rollback the transaction at a later point.]
+
The container may create the representation of the entity in the database immediately, or it can defer it to a later time (for example to the time after the matching `ejbPostCreate<METHOD>` has been called, or to the end of the transaction), depending on the caching strategy that it uses.
+
The container then invokes the matching `ejbPostCreate<METHOD>` method with the same arguments on the instance to allow the instance to fully initialize itself.
The instance can discover the primary key by calling the getPrimaryKey method on its entity context object.
+
Finally, the container returns the entity object’s remote interface (i.e., a reference to the entity EJBObject) to the client if the client is a remote client or the entity object’s local interface (i.e., a reference to the entity EJBLocalObject) if the client is a local client.
+
The container must invoke the `ejbCreate<METHOD>` and `ejbPostCreate<METHOD>` methods and create the representation of the persistent instance in the database in the transaction context determined by the transaction attribute of the matching `create<METHOD>` method, as described in Enterprise Beans Core Contracts and Requirements document <<a3339>>
Subsection "`Container-Managed Transaction Demarcation for Business
Methods`".

* `public void ejbActivate();`
+
The container invokes this method on an entity bean instance at activation time (i.e., when the instance is taken from the pool and assigned to an entity object identity).
The container must ensure that the primary key of the associated entity object is available to the instance if the instance invokes the `getPrimaryKey`, `getEJBLocalObject`, or `getEJBObject` method on its `EntityContext` interface.
+
The container invokes this method with an unspecified transaction context.
+
Note that instance is not yet ready for the delivery of a business method.
The container must still invoke the ejbLoad method prior to a business method.

* `public void ejbPassivate();`
+
The container invokes this method on an entity bean instance at passivation time (i.e., when the instance is being disassociated from an entity object identity and moved into the pool).
The container must ensure that the identity of the associated entity object is still available to the instance if the instance invokes the `getPrimaryKey`, `getEJBLocalObject`, or `getEJBObject` method on its entity context.
+
The container invokes this method with an unspecified transaction context.
+
Note that if the instance state has been updated by a transaction, the container must first invoke the `ejbStore` method on the instance before it invokes `ejbPassivate` on it.

* `public void ejbRemove();`
+
The container invokes the `ejbRemove` method in response to a client-invoked remove operation on the entity bean’s home or component interface or as the result of a cascade-delete operation.
The instance is in the ready state when `ejbRemove` is invoked and it will be entered into the pool when the method completes.
+
The container synchronizes the instance’s state before it invokes the `ejbRemove` method.
This means that the persistent state of the instance at the beginning of the `ejbRemove` method is the same as it would be at the beginning of a business method (i.e., if the instance is not already synchronized from the state in the database, the container must invoke `ejbLoad` before it invokes `ejbRemove`).
+
The container must ensure that the identity of the associated entity object is still available to the instance in the `ejbRemove` method (i.e., the instance can invoke the `getPrimaryKey`, `getEJBLocalObject`, or `getEJBObject` method on its `EntityContext` in the `ejbRemove` method).
+
After the entity Bean Provider’s `ejbRemove` method returns, and in the same transaction context, the container removes the entity bean instance from all relationships in which it participates and then removes the entity object’s persistent representation.
+
The container may delete the representation of the entity in the database immediately, or it can defer it to a later time (for example to the end of the transaction), depending on the caching strategy that it uses.
+
The container must ensure that the `ejbRemove` method and database delete operations are performed in the transaction context determined by the transaction attribute of the invoked remove method, as described in Enterprise Beans Core Contracts and Requirements document <<a3339>> Subsection "`Container-Managed Transaction Demarcation for Business Methods`".

* `public void ejbLoad();`
+
When the container needs to synchronize the state of an enterprise bean instance with the entity object’s state in the database, the container calls the `ejbLoad` method.
Depending on its caching strategy, the container may first read the entity object’s state from the database, before invoking the `ejbLoad` method, or it may use a lazy loading strategy in making this state visible to the instance.
+
The exact times that the container invokes `ejbLoad` depend on the configuration of the component and the container, and are not defined by the Enterprise Beans architecture.
Typically, the container will call `ejbLoad` before the first business method within a transaction or before invoking the `ejbTimeout` method on an instance.
+
The container must invoke this method in the transaction context determined by the transaction attribute of the business method or `ejbTimeout` method that triggered the `ejbLoad` method.

* `public void ejbStore();`
+
When the container needs to synchronize the state of the entity object in the database with the state of the enterprise bean instance, the container calls the `ejbStore` method on the instance.
This synchronization always happens at the end of a transaction, unless the bean is specified as read-only (see <<a1342>>).
However, the container may also invoke this method when it passivates the instance in the middle of a transaction, or when it needs to transfer the most recent state of the entity object to another instance for the same entity object in the same transaction.
+
The container must invoke this method in the same transaction context as the previous `ejbLoad`, `ejbCreate<METHOD>`, or `ejbTimeout` method invoked on the instance.
All business methods or the `ejbTimeout` method invoked between the previous `ejbLoad` or `ejbCreate<METHOD>` method and this `ejbStore` method are also invoked in the same transaction context.
+
After the `ejbStore` method returns, the container may store the persistent state of the instance to the database, depending on its caching strategy.
If the container uses a lazy storing caching strategy, it is the container’s responsibility to write the representation of the persistent object to the database in the same transaction context as that of the `ejbStore` method.

* `public` _<primary key type or collection>_ `ejbFind<METHOD>(...);`
+
The implementation of the `ejbFind<METHOD>` method is supplied by the container.
+
The container invokes the `ejbFind<METHOD>` method on an instance when a client invokes a matching `find<METHOD>` method on the entity bean’s home interface.
The container must pick an instance that is in the pooled state (i.e., the instance is not associated with any entity object identity) for the execution of the `ejbFind<METHOD>` method.
If there is no instance in the pooled state, the container creates one and calls the `setEntityContext` method on the instance before dispatching the finder method.
+
The container must invoke the `ejbFind<METHOD>` method in the transaction context determined by the transaction attribute of the matching find method, as described in Enterprise Beans Core Contracts and Requirements document <<a3339>> Subsection "`Container-Managed Transaction Demarcation for Business Methods`".
+
The container is responsible for ensuring that updates to the states of all entity beans in the same transaction context as the `ejbFind<METHOD>` method and whose abstract schema types are accessed in the method’s Enterprise Beans QL query are visible in the results of the `ejbFind<METHOD>` method.
Before invoking the `ejbFind<METHOD>` method, the container must first synchronize the state of those entity bean instances by invoking the `ejbStore` method on them.
This requirement does not apply to the `ejbFindByPrimaryKey` method.
The results of the `ejbFindByPrimaryKey` method, however, must reflect the entities that have been created or removed within the same transaction context.
+
After the `ejbFind<METHOD>` method completes, the instance remains in the pooled state.
The container may, but is not required to, immediately activate the objects that were located by the finder using the transition through the `ejbActivate` method.
+
If the `ejbFind<METHOD>` method is declared to return a single primary key, the container creates an entity EJBObject (EJBLocalObject) reference for the primary key and returns it to the client (local client).
If the `ejbFind<METHOD>` method is declared to return a collection of primary keys, the container creates a collection of entity EJBObject (EJBLocalObject) references for the primary keys returned from the `ejbFind<METHOD>` method, and returns the collection to the client (local client).
+
The implementations of the finder methods are generated at the entity bean deployment time using the Container Provider’s tools.

* `public` _<type>_ `ejbSelect<METHOD>(...);`
+
A select method is a query method that is not directly exposed to the client in the home or component interface.
The Bean Provider typically calls a select method within a business method or home method.
+
A select method executes in the transaction context determined by the transaction attribute of the invoking business method.
+
The container is responsible for ensuring that all updates to the states of all entity beans in the same transaction context as the `ejbSelect<METHOD>` method and whose abstract schema types are accessed in the Enterprise Beans QL query for the `ejbSelect<METHOD>` method are visible in the results of the `ejbSelect<METHOD>` method by invoking the `ejbStore` method on those entity bean instances.
+
The implementations of the select methods are generated at the entity bean deployment time using the Container Provider’s tools.

* `public <type> ejbHome<METHOD>(...);`
+
The container invokes the `ejbHome<METHOD>` method on an instance when a client invokes a matching <METHOD> home method on the entity bean’s home interface.
The container must pick an instance that is in the pooled state (i.e., the instance is not associated with any entity object identity) for the execution of the `ejbHome<METHOD>` method.
If there is no instance in the pooled state, the container creates one and calls the `setEntityContext` method on the instance before dispatching the home method.
+
After the `ejbHome<METHOD>` method completes, the instance remains in the pooled state.
+
The container must invoke the `ejbHome<METHOD>` method in the transaction context determined by the transaction attribute of the matching <METHOD> home method, as described in Enterprise Beans Core Contracts and Requirements document <<a3339>> Subsection "`Container-Managed Transaction Demarcation for Business Methods`".

* `public void ejbTimeout(...);`
+
The container invokes the `ejbTimeout` method on the instance when a timer with which the entity has been registered expires.
If there is no suitable instance in the ready state, the container must activate an instance, invoking the `ejbActivate` method and transitioning it to the ready state.
+
The container invokes the `ejbTimeout` method in the context of a transaction determined by its transaction attribute.

[[a1342]]
==== Read-only Entity Beans

Compliant implementations of this specification may optionally support read-only entity beans.
A read-only entity bean is an entity bean whose instances are not intended to be updated and/or created by the application.
Read-only beans are best suited for situations where the underlying data never changes or changes infrequently.

Containers that support read-only beans do not call the `ejbStore` method on them.
The `ejbLoad` method should typically be called by the container when the state of the bean instance is initially loaded from the database, or at designated refresh intervals.
footnote:a3373[The ability to refresh the state of a read-only bean and the intervals at which such refresh occurs are vendor-specific.]

If a read-only bean is used, the state of such a bean should not be updated by the application, and the behavior is unspecified if this occurs.
footnote:a3374[For example, an implementation might choose to ignore such updates or to disallow them.]

Read-only beans are designated by vendor-specific means that are outside the scope of this specification, and their use is therefore not portable.

==== The EntityContext Interface

A container provides the entity bean instances with an `EntityContext`, which gives the entity bean instance access to the instance’s context maintained by the container.
The `EntityContext` interface has the following methods:

* The `getEJBObject` method returns the entity bean’s remote interface.

* The `getEJBHome` method returns the entity bean’s remote home interface.

* The `getEJBLocalObject` method returns the entity bean’s local interface.

* The `getEJBLocalHome` method returns the entity bean’s local home interface.

* The `getCallerPrincipal` method returns the `java.security.Principal` that identifies the invoker.

* The `isCallerInRole` method tests if the entity bean instance’s caller has a particular role.

* The `setRollbackOnly` method allows the instance to mark the current transaction such that the only outcome of the transaction is a rollback.

* The `getRollbackOnly` method allows the instance to test if the current transaction has been marked for rollback.

* The `getPrimaryKey` method returns the entity bean’s primary key.

* The `getTimerService` method returns the `jakarta.ejb.TimerService` interface.

* The `getUserTransaction` method returns the `jakarta.transaction.UserTransaction` interface.
Entity bean instances must not call this method.

* The `lookup` method enables the entity bean to look up its environment entries in the JNDI naming context.

==== Operations Allowed in the Methods of the Entity Bean Class

<<a1367>> defines the methods of an entity bean class in which the enterprise bean instances can access the methods of the `jakarta.ejb.EntityContext` interface, the `java:comp/env` environment naming context, resource managers, `TimerService` and `Timer` methods, the `EntityManager` and `EntityManagerFactory` methods, and other enterprise beans.

If an entity bean instance attempts to invoke a method of the `EntityContext` interface, and the access is not allowed in <<a1367>>, the container must throw the `java.lang.IllegalStateException`.

If a entity bean instance attempts to invoke a method of the `TimerService` or `Timer` interface and the access is not allowed in <<a1367>>, the container must throw the `java.lang.IllegalStateException`.

If an entity bean instance attempts to access a resource manager, an enterprise bean, an entity manager or entity manager factory, and the access is not allowed in <<a1367>>, the behavior is undefined by the Enterprise Beans architecture.

[[a1367]]
.Operations Allowed in the Methods of an Entity Bean
[cols=".>33%,67%", options="header"]
|===
|Bean method
|Bean method can perform the following operations

|constructor
|-

|setEntityContext +
unsetEntityContext
|EntityContext methods: `getEJBHome`, `getEJBLocalHome`, `lookup` +
JNDI access to java:comp/env

|ejbCreate
|EntityContext methods: `getEJBHome`, `getEJBLocalHome`, `getCallerPrincipal`, `getRollbackOnly`, `isCallerInRole`,`setRollbackOnly`, `getTimerService`, `lookup` +
JNDI access to java:comp/env +
Resource manager access +
Enterprise bean access +
EntityManagerFactory access +
EntityManager access

|ejbPostCreate
|EntityContext methods: `getEJBHome`, `getEJBLocalHome`, `getCallerPrincipal`, `getRollbackOnly`, `isCallerInRole`, `setRollbackOnly`, `getEJBObject`, `getEJBLocalObject`, `getPrimaryKey`, `getTimerService`, `lookup` +
JNDI access to java:comp/env +
Resource manager access +
Enterprise bean access +
Timer service or Timer methods +
EntityManagerFactory access +
EntityManager access

|ejbRemove
|EntityContext methods: `getEJBHome`, `getEJBLocalHome`, `getCallerPrincipal`, `getRollbackOnly`, `isCallerInRole`, `setRollbackOnly`, `getEJBObject`, `getEJBLocalObject`, `getPrimaryKey`, `getTimerService`, `lookup` +
JNDI access to java:comp/env +
Resource manager access +
Enterprise bean access +
Timer service or Timer methods +
EntityManagerFactory access +
EntityManager access

|ejbHome
|EntityContext methods: `getEJBHome`, `getEJBLocalHome`, `getCallerPrincipal`, `getRollbackOnly`, `isCallerInRole`, `setRollbackOnly`, `getTimerService`, `lookup` +
JNDI access to java:comp/env +
Resource manager access +
Enterprise bean access +
EntityManagerFactory access +
EntityManager access

|ejbActivate +
ejbPassivate
|EntityContext methods: `getEJBHome`, `getEJBLocalHome`, `getEJBObject`, `getEJBLocalObject`, `getPrimaryKey`, `getTimerService`, `lookup` +
JNDI access to java:comp/env

|ejbLoad +
ejbStore
|EntityContext methods: `getEJBHome`, `getEJBLocalHome`, `getCallerPrincipal`, `getRollbackOnly`, `isCallerInRole`, `setRollbackOnly`, `getEJBObject`, `getEJBLocalObject`, `getPrimaryKey`, `getTimerService`, `lookup` +
JNDI access to java:comp/env +
Resource manager access +
Enterprise bean access +
Timer service or Timer methods +
EntityManagerFactory access +
EntityManager access

|business method from component interface
|EntityContext methods: `getEJBHome`, `getEJBLocalHome`, `getCallerPrincipal`, `getRollbackOnly`, `isCallerInRole`, `setRollbackOnly`, `getEJBObject`, `getEJBLocalObject`, `getPrimaryKey`, `getTimerService`, `lookup` +
JNDI access to java:comp/env +
Resource manager access +
Enterprise bean access +
Timer service or Timer methods +
EntityManagerFactory access +
EntityManager access

|ejbTimeout
|EntityContext methods: `getEJBHome`, `getEJBLocalHome`, `getRollbackOnly`, `setRollbackOnly`, `getCallerPrincipal`, `isCallerInRole`, `getEJBObject`, `getEJBLocalObject`, `getPrimaryKey`, `getTimerService`, `lookup` +
JNDI access to java:comp/env +
Resource manager access +
Enterprise bean access +
Timer service or Timer methods +
EntityManagerFactory access +
EntityManager access
|===

Additional restrictions:

* The `getRollbackOnly` and `setRollbackOnly` methods of the `EntityContext` interface should be used only in the enterprise bean methods that execute in the context of a transaction.
The container must throw the `java.lang.IllegalStateException` if the methods are invoked while the instance is not associated with a transaction.

Reasons for disallowing operations:

* Invoking the `getEJBObject`, `getEJBLocalObject`, and `getPrimaryKey` methods is disallowed in the entity bean methods in which there is no entity object identity associated with the instance.

* Invoking the `getEJBObject` and `getEJBHome` methods is disallowed if the entity bean does not define a remote client view.

* Invoking the `getEJBLocalObject` and `getEJBLocalHome` methods is disallowed if the entity bean does not define a local client view.

* Invoking the `getRollbackOnly` and `setRollbackOnly` methods is disallowed in the entity bean methods for which the container does not have a meaningful transaction context.

* Accessing resource managers and enterprise beans, including accessing the persistent state of an entity bean instance, is disallowed in the entity bean methods for which the container does not have a meaningful transaction context or client security context.

[[a1446]]
==== Finder Methods

An entity bean’s home interface defines one or more finder
methods
footnote:a3375[The `findByPrimaryKey` method is mandatory for all entity beans.]
, one for each way to find an entity object or collection of entity objects within the home.
The name of each finder method starts with the prefix "```find```", such as `findLargeAccounts`.
The arguments of a finder method are used in the implementation of the query for the finder method to locate the requested entity objects.

Every finder method except `findByPrimaryKey(key)` must be associated with a `query` element in the deployment descriptor.
The entity Bean Provider declaratively specifies the Enterprise Beans QL finder query and associates it with the finder method in the deployment descriptor.
A finder method is normally characterized by an Enterprise Beans QL query string specified in the `query` element.
Enterprise Beans QL is described in <<a1840>>.
A compliant implementation of this specification is required to support Enterprise Beans QL as defined in <<a1840>> for use with finder methods.

In the case that both the remote home interface and local home interface define a finder method with the same name and argument types, the Enterprise Beans QL query string specified by the `query` element defines the semantics of both methods.

===== Single-Object Finder Methods

Some finder methods (such as `findByPrimaryKey`) are designed to return at most one entity object.
For single-object finders, the result type of a `find<METHOD>` method defined in the entity bean’s remote home interface is the entity bean’s remote interface, and the result type of the `find<METHOD>` method defined in the entity bean’s local home interface is the entity bean’s local interface.

The following code illustrates the definition of a single-object finder defined on the remote home interface.
[source, java]
----
// Entity’s home interface
public interface AccountHome extends jakarta.ejb.EJBHome {
    ...
    Account findByPrimaryKey(AccountPrimaryKey primkey)
         throws FinderException, RemoteException;
    ...
}
----

****
_Note that a finder method defined on the local home interface must not throw the `RemoteException`._
****

In general, when defining a single-object finder method other than `findByPrimaryKey`, the entity Bean Provider should be sure that the finder method will always return only a single entity object.
This may occur, for example, if the Enterprise Beans QL query string that is used to specify the finder query includes an equality test on the entity bean’s primary key fields.
If the entity Bean Provider uses an unknown primary key class (see <<a1833>>), the Bean Provider will typically define the finder method as a multi-object finder.

Note that a single-object finder method may return a null value.
If the result set of the query consists of a single null value, the container must return the null value as the result of the method.
If the result set of a query for a single-object finder method contains more than one value (whether non-null, null, or a combination), the container must throw the `FinderException` from the finder method.
If the result set of the query contains no values, the container must throw the `ObjectNotFoundException`.

===== Multi-Object Finder Methods

Some finder methods are designed to return multiple entity objects.
For multi-object finders defined on the entity bean’s local home interface, the result type of the `find<METHOD>` method is a collection of objects implementing the entity bean’s local interface.
For multi-object finders defined on the entity bean’s remote home interface, the result type of the `find<METHOD>` method is a collection of objects implementing the entity bean’s remote interface.

The Bean Provider uses the `java.util.Collection` interface to define a collection type for the result type of a finder method for an entity bean with container-managed persistence.

The collection of values returned by the container may contain duplicates if DISTINCT is not specified in the SELECT clause of the query for the finder method.

The collection of values returned by the container may contain null values if the finder method returns the values of a cmr-field and null values are not eliminated by the query.

A portable client program must use the `PortableRemoteObject.narrow` method to convert the objects contained in the collections returned by a finder method on the entity bean’s remote home interface to the entity bean’s remote interface type.

The following is an example of a multi-object finder method defined on the remote home interface:
[source, java]
----
// Entity’s home interface
public interface AccountHome extends jakarta.ejb.EJBHome {
    ...
    java.util.Collection findLargeAccounts(double limit)
        throws FinderException, RemoteException;
    ...
}
----

****
_Note that if this finder method were defined
on the local home interface, it would not throw the `RemoteException`._
****

[[a1479]]
==== Select Methods

Select methods are query methods for use by the Bean Provider within an entity bean instance.
Unlike finder methods, select methods are not specified in the entity bean’s home interface.
A select method is an abstract method defined by the Bean Provider on an entity bean class.
A select method must not be exposed in the home or component interface of an entity bean.

The semantics of a select method, like those of a finder method, are defined by an Enterprise Beans QL query string.
A select method is similar to a finder method, but unlike a finder method, but it can return values that correspond to any cmp- or cmr-field type.

Every select method must be associated with a `query` element in the deployment descriptor.
The entity Bean Provider declaratively specifies the Enterprise Beans QL query and associates it with the select method in the deployment descriptor.
A select method is normally characterized by an Enterprise Beans QL query string specified in the `query` element.
Enterprise Beans QL is described in <<a1840>>.
A compliant implementation of this specification is required to support Enterprise Beans QL as defined in <<a1840>> for use with select methods.

Typically an `ejbSelect<METHOD>` method that returns entity objects returns these as EJBLocalObjects.
If the `ejbSelect<METHOD>` method returns an EJBObject or collection of EJBObjects, the Bean Provider must specify the value of the `result-type-mapping` element in the `query` deployment descriptor element for the select method as `Remote`.

An `ejbSelect<METHOD>` is not based on the identity of the entity bean instance on which it is invoked.
However, the Bean Provider can use the primary key of an entity bean as an argument to an `ejbSelect<METHOD>` to define a query that is logically scoped to a particular entity bean instance.

The following table illustrates the semantics of finder and select methods.

.Comparison of Finder and Select Methods
[width="100%",cols=".^20%h,40%,40%",options="header",]
|===
| 
|Finder methods
|Select methods
|method 
m|find<METHOD>
m|ejbSelect<METHOD>

|visibility
|exposed to client
|internal to entity bean class

|instance
|arbitrary bean instance in pooled state
|instance: current instance (could be bean instance in pooled state or ready state)

|return value
|EJBObjects or EJBLocalObjects of the same type as the entity bean 
|EJBObjects, EJBLocalObjects, or cmp-field types
|===

===== Single-Object Select Methods

Some select methods are designed to return at most one value.
In general, when defining a single-object select method, the entity Bean Provider must be sure that the select method will always return only a single object or value.
If the query specified by the select method returns multiple values of the designated type, the container must throw the `FinderException`.

Note that a single-object select method may return a null value.
If the result set of the query consists of a single null value, the container must return the null value as the result of the method.
If the result set of a query for a single-object select method contains more than one value (whether non-null, null, or a combination), the container must throw the `FinderException` from the select method.
If the result set of the query contains no values, the contain must throw the `ObjectNotFoundException`.

The Bean Provider will typically define a select method as a multi-object select method.

===== Multi-Object Select Methods

Some select methods are designed to return multiple values.
For these multi-object select methods, the result type of the `ejbSelect<METHOD>` method is a collection of objects.

The Bean Provider uses the `java.util.Collection` interface or `java.util.Set` interface to define a collection type for the result type of a select method.
The type of the elements of the collection is determined by the type of the SELECT clause of the corresponding Enterprise Beans QL query.
If the Bean Provider uses the `java.util.Collection` interface, the collection of values returned by the container may contain duplicates if DISTINCT is not specified in the SELECT clause of the query.
If a query for a select method whose result type is `java.util.Set` does not specify DISTINCT in its SELECT clause, the container must interpret the query as if SELECT DISTINCT had been specified.

The collection of values returned by the container may contain null values if the select method returns the values of a cmr-field or cmp-field and null values are not eliminated by the query.

The following is an example of a multi-object select method definition in the `OrderBean` class:
[source, java]
----
// OrderBean implementation class
public abstract class OrderBean implements jakarta.ejb.EntityBean {
    ...
    public abstract java.util.Collection
                ejbSelectAllOrderedProducts(Customer customer)
        throws FinderException;
    // internal finder method to find all products ordered
}
----

==== Timer Notifications

An entity bean can be registered with the Enterprise Beans timer service for time-based event notifications if it implements the `jakarta.ejb.TimedObject` interface.
The container invokes the bean instance’s `ejbTimeout` method when a timer for the bean has expired.
See <<a3258>>.

[[a1524]]
==== Standard Application Exceptions for Entities

The Enterprise Beans specification defines the following standard application exceptions:

* jakarta.ejb.CreateException

* jakarta.ejb.DuplicateKeyException

* jakarta.ejb.FinderException

* jakarta.ejb.ObjectNotFoundException

* jakarta.ejb.RemoveException

This section describes the use of these exceptions by entity beans with container-managed persistence.

===== CreateException

From the client’s perspective, a `CreateException` (or a subclass of `CreateException`) indicates that an application level error occurred during a `create<METHOD>` operation.
If a client receives this exception, the client does not know, in general, whether the entity object was created but not fully initialized, or not created at all.
Also, the client does not know whether or not the transaction has been marked for rollback.
(However, the client may determine the transaction status using the `UserTransaction` interface or the `setRollbackOnly` method of the `EJBContext` interface.)

Both the container and the Bean Provider may throw the `CreateException` (or subclass of `CreateException`) from the `create<METHOD>`, `ejbCreate<METHOD>` and `ejbPostCreate<METHOD>` methods to indicate an application-level error from the create or initialization operation.
Optionally, the container or Bean Provider may mark the transaction for rollback before throwing this exception.

_The container or Bean Provider is encouraged to mark the transaction for rollback only if data integrity would be lost if the transaction were committed by the client._
_Typically, when a `CreateException` is thrown, it leaves the database in a consistent state, allowing the client to recover._
_For example, the `ejbCreate<METHOD>` method may throw the `CreateException` to indicate that the some of the arguments to the `create<METHOD>` method are invalid._

The container treats the `CreateException` as any other application exception.
See <<a3227>>.

===== DuplicateKeyException

The `DuplicateKeyException` is a subclass of `CreateException`.
It may be thrown by the container to indicate to the client or local client that the entity object cannot be created because an entity object with the same key already exists.
The unique key causing the violation may be the primary key, or another key defined in the underlying database.

Normally, the container should not mark the transaction for rollback before throwing the exception.

When the client or local client receives a `DuplicateKeyException`, the client knows that the entity was not created, and that the transaction has not typically been marked for rollback.

===== FinderException

From the client’s perspective, a `FinderException` (or a subclass of `FinderException`) indicates that an application level error occurred during the find operation.
Typically, the transaction has not been marked for rollback because of the `FinderException`.

The container throws the `FinderException` (or subclass of `FinderException`) from the implementation of a finder or select method to indicate an application-level error in the finder or select method.
The container should not, typically, mark the transaction for rollback before throwing the `FinderException`.

The container treats the `FinderException` as any other application exception.
See <<a3227>>.

===== ObjectNotFoundException

The `ObjectNotFoundException` is a subclass of `FinderException`.
The container throws the `ObjectNotFoundException` from the implementation of a finder or select method to indicate that the requested object does not exist.

Only single-object finder or select methods (see <<a1446>> and <<a1479>>) should throw this exception.
Multi-object finder or select methods must not throw this exception.
Multi-object finder or select methods should return an empty collection as an indication that no matching objects were found.

===== RemoveException

From the client’s perspective, a `RemoveException` (or a subclass of `RemoveException`) indicates that an application level error occurred during a remove operation.
If a client receives this exception, the client does not know, in general, whether the entity object was removed or not.
The client also does not know if the transaction has been marked for
rollback.
(However, the client may determine the transaction status using the `UserTransaction` interface.)

The container or Bean Provider throws the `RemoveException` (or subclass of `RemoveException`) from a remove method to indicate an application-level error from the entity object removal operation.
Optionally, the container or Bean Provider may mark the transaction for rollback before throwing this exception.

_The container or Bean Provider is encouraged to mark the transaction for rollback only if data integrity would be lost if the transaction were committed by the client._
_Typically, when a `RemoveException` is thrown, it leaves the database in a consistent state, allowing the client to recover._

The container treats the `RemoveException` as any other application exception.
See <<a3227>>.

[[a1554]]
==== Commit Options

The Entity Bean protocol is designed to give the container the flexibility to select the disposition of the instance state at transaction commit time.
This flexibility allows the container to optimally manage the association of an entity object identity with the enterprise bean instances.

The container can select from the following commit-time options:

* **Option A:**
The container caches a "`ready`" instance between transactions.
The container knows that the bean instance has exclusive access to the state of the object in the persistent storage.
Therefore, the container does not have to synchronize the instance’s state from the persistent storage at the beginning of the next transaction or have to verify that the instance’s state is in sync with the persistent storage at the beginning of the next transaction.

* **Option B:**
The container caches a "`ready`" instance between transactions.
In contrast to Option A, in this option the instance may not have exclusive access to the state of the object in the persistent storage.
Therefore, the container must synchronize the instance’s state from the persistent storage at the beginning of the next transaction if the instance’s state in the persistent storage has changed.
Containers using optimistic concurrency control strategies may instead choose to rollback the transaction if this invariant has not been met:
The container must ensure that in order for a transaction to be successfully committed, the transaction must only operate on instance data that is in sync with the persistent storage at the beginning of the transaction.

* **Option C:**
The container does not cache a "`ready`" instance between transactions.
The container returns the instance to the pool of available instances after a transaction has completed.

Variants of these strategies that capture the same semantics from the Bean Provider’s viewpoint may be employed, e.g., to optimize data access.

The following illustrative lazy loading strategies are consistent with the intent of these requirements:

* If `ejbLoad` is called at the beginning of the transaction without the instance’s persistent state having been loaded from the persistent storage, the persistent state must be faulted in when `ejbLoad` causes the bean’s getter accessor methods to be invoked.
If the `ejbLoad` method is empty, data may be faulted in as needed in the course of executing the businesss methods of the bean.

* If the instance’s persistent state is cached between transactions, `ejbLoad` need not be called and persistent data need not be faulted in from the persistent storage (unless it has not previously been accessed).
In this case, because `ejbLoad` has been previously called when the instance was entered into the ready state for the first time, and because the bean instance’s state is consistent with its persistent state, there is no need to call `ejbLoad` unless the instance’s state in the persistent storage has changed.
In this case, the container must ensure that in order for the transaction to be successfully committed, the instance’s persistent state was in sync with the persistent storage at the beginning of the transaction.

The following table provides a summary of the commit-time options.

.Summary of Commit-Time Options
[cols="4", options="header"]
|===
|
|Write instance state to database
|Instance stays ready
|Instance state remains valid

|Option A
|Yes
|Yes
|Yes

|Option B
|Yes
|Yes
|No

|Option C
|Yes
|No
|No
|===

Note that the container synchronizes the instance’s state with the persistent storage at transaction commit for all three options.

The selection of the commit option is transparent to the entity bean implementation—the entity bean will work correctly regardless of the commit-time option chosen by the container.
The Bean Provider writes the entity bean in the same way.

****
_Note: The Bean Provider relies on the `ejbLoad` method to be invoked in order to resynchronize the bean’s transient state with its persistent state.
It is the responsibility of the container to call the `ejbLoad` method at the beginning of a new transaction if the bean instance’s persistent data has changed.
footnote:a3376[It is consistent with this specification to provide options for this refresh to be deferred or avoided in the case of read-only beans.]_
****

==== Concurrent Access from Multiple Transactions

When writing the entity bean business methods, the Bean Provider does not have to worry about concurrent access from multiple transactions.
The Bean Provider may assume that the container will ensure appropriate synchronization for entity objects that are accessed concurrently from multiple transactions.

The container typically uses one of the following implementation strategies to achieve proper synchronization.
(These strategies are illustrative, not prescriptive.)

* The container activates multiple instances of the entity bean, one for each transaction in which the entity object is being accessed.
The transaction synchronization is performed by the underlying database during the accessor method calls performed by the business methods, the `ejbTimeout` method, and by the `ejbLoad`, `ejbCreate<METHOD>`, `ejbStore`, and `ejbRemove` methods.
The commit-time options B and C in <<a1554>> apply to this type of container.

.Multiple Clients Can Access the Same Entity Object Using Multiple Instances
image::EBOpt-35.svg[]

_With this strategy, the type of lock acquired by `ejbLoad` or get accessor method (if a lazy loading cache management strategy is used) leads to a trade-off.
If `ejbLoad` or the accessor method acquires an exclusive lock on the instance's state in the database, the throughput of read-only transactions could be impacted.
If `ejbLoad` or the accessor method acquires a shared lock and the instance is updated, then either `ejbStore` or a set accessor method will need to promote the lock to an exclusive lock (which may cause a deadlock if it happens concurrently under multiple transactions), or, if the container uses an optimistic cache concurrency control strategy, the container will need to validate the state of the cache against the database at transaction commit (which may result in a rollback of the transaction)._

It is expected that containers will provide deployment-time configuration options that will allow control to be exercised over the logical transaction isolation levels that their caching strategies provide.

* The container acquires exclusive access to the entity object’s state in the database.
The container activates a single instance and serializes the access from multiple transactions to
this instance.
The commit-time option A in <<a1554>> applies to this type of container.

.Multiple Clients Can Access the Same Entity Object Using Single Instance
image::EBOpt-36.svg[]

[[a1596]]
==== Non-reentrant and Re-entrant Instances

An entity Bean Provider can specify that an entity bean is non-reentrant.
If an instance of a non-reentrant entity bean executes a client request in a given transaction context, and another request with the same transaction context arrives for the same entity object, the container will throw an exception to the second request.
This rule allows the Bean Provider to program the entity bean as single-threaded, non-reentrant code.

The functionality of entity beans with container-managed persistence may require loopbacks in the same transaction context.
An example of a loopback is when the client calls entity object A, A calls entity object B, and B calls back A in the same transaction context.
The entity bean’s method invoked by the loopback shares the current execution context (which includes the transaction and security contexts) with the Bean’s method invoked by the client.

If the entity bean is specified as non-reentrant in the deployment descriptor, the container must reject an attempt to re-enter the instance via the entity bean’s component interface while the instance is executing a business method.
(This can happen, for example, if the instance has invoked another enterprise bean, and the other enterprise bean tries to make a loopback call.)
If the attempt is made to reenter the instance through the remote interface, the container must throw the `java.rmi.RemoteException` to the caller.
If the attempt is made to reenter the instance through the local interface, the container must throw the `jakarta.ejb.EJBException` to the caller.
The container must allow the call if the Bean’s deployment descriptor specifies that the entity bean is re-entrant.

Re-entrant entity beans must be programmed and used with caution.
First, the Bean Provider must code the entity bean with the anticipation of a loopback call.
Second, since the container cannot, in general, tell a loopback from a concurrent call from a different client, the client programmer must be careful to avoid code that could lead to a concurrent call in the same transaction context.

Concurrent calls in the same transaction context targeted at the same entity object are illegal and may lead to
unpredictable results.
Since the container cannot, in general, distinguish between an illegal concurrent call and a legal loopback, application programmers are encouraged to avoid using loopbacks.
Entity beans that do not need callbacks should be marked as non-reentrant in the deployment descriptor, allowing the container to detect and prevent illegal concurrent calls from clients.

=== Responsibilities of the Enterprise Bean Provider

This section describes the responsibilities of an entity Bean Provider to ensure that an entity bean with container-managed persistence can be deployed in any Enterprise Beans container.

==== Classes and Interfaces

The entity Bean Provider is responsible for providing the following class files:

* Entity bean class and any dependent classes

* Primary key class

* Entity bean’s remote interface and entity bean’s remote home interface, if the entity bean provides a remote client view

* Entity bean’s local interface and local home interface, if the entity bean provides a local client view

The Bean Provider must provide a remote interface and a remote home interface or a local interface and a local home interface for the bean.
The Bean Provider may provide a remote interface, remote home interface, local interface, and local home interface for the bean.
Other combinations are not allowed.

==== Enterprise Bean Class

The following are the requirements for an entity bean class:

The class must implement, directly or indirectly, the `jakarta.ejb.EntityBean` interface.

The class may implement, directly or indirectly, the `jakarta.ejb.TimedObject` interface.

The class must be defined as public and must be abstract.
The class must be a top level class.

The class must define a public constructor that takes no arguments.

The class must not define the finalize() method.

The class may, but is not required to, implement the entity bean’s component interface.
footnote:a3377[If the entity bean class does implement the component interface, care must be taken to avoid passing of this as a method argument or result.
This potential error can be avoided by choosing not to implement the component interface in the entity bean class.]
If the class implements the entity bean’s component interface, the class must provide no-op implementations of the methods defined by that interface.
The container will never invoke these methods on the bean instances at runtime.

The entity bean class must implement the business methods, and the `ejbCreate<METHOD>` and `ejbPostCreate<METHOD>` methods as described later in this section.

The entity bean class must implement the `ejbHome<METHOD>` methods that correspond to the home business methods specified in the bean’s home interface.
These methods are executed on an instance in the pooled state; hence they must not access state that is particular to a specific bean instance (e.g., the accessor methods for the bean’s abstract persistence schema must not be used by these methods).

The entity bean class must implement the get and set accessor methods of the bean’s abstract persistence schema as `abstract` methods.

The entity bean class may have superclasses and/or superinterfaces.
If the entity bean has superclasses, the business methods, the `ejbCreate<METHOD>` and `ejbPostCreate<METHOD>` methods, and the methods of the `EntityBean` interface and/or the `TimedObject` interface may be implemented in the enterprise bean class or in any of its superclasses.

The entity bean class is allowed to implement other methods (for example helper methods invoked internally by the business methods) in addition to the methods required by the Enterprise Beans specification.

The entity bean class does not implement the finder methods.
The implementations of the finder methods are provided by the container.

The entity bean class must implement any `ejbSelect<METHOD>` methods as abstract methods.

==== Dependent Value Classes

The following are the requirements for a dependent value class:

The class must be defined as `public` and must not be `abstract`.

The class must be serializable.

==== ejbCreate<METHOD> Methods

The entity bean class must implement the `ejbCreate<METHOD>` methods that correspond to the `create<METHOD>` methods specified in the entity bean’s home interface or local home interface.

The entity bean class may define zero or more `ejbCreate<METHOD>` methods whose signatures must follow these rules:

The method name must have `ejbCreate` as its prefix.

The method must be declared as `public`.

The method must not be declared as `final` or `static`.

The return type must be the entity bean’s primary key type.

If the `ejbCreate<METHOD>` method corresponds to a `create<METHOD>` on the entity bean’s remote home interface, the method arguments and return value types must be legal types for RMI-IIOP.

The `throws` clause must define the `jakarta.ejb.CreateException`.
The `throws` clause may define arbitrary application specific exceptions.

_Compatibility Note: Enterprise Beans 1.0 allowed the `ejbCreate` method to throw the `java.rmi.RemoteException` to indicate a non-application exception.
This practice was deprecated in Enterprise Beans 1.1—an Enterprise Beans 1.1 or Enterprise Beans 2.0 or later compliant enterprise bean should throw the `jakarta.ejb.EJBException` or another `java.lang.RuntimeException` to indicate non-application exceptions to the container (see <<a3221>>).
The `ejbCreate` method of an entity bean with cmp-version 2.x must not throw the `java.rmi.RemoteException`._

==== ejbPostCreate<METHOD> Methods

For each `ejbCreate<METHOD>` method, the entity bean class must define a matching `ejbPostCreate<METHOD>` method, using the following rules:

The method name must have `ejbPostCreate` as its prefix.

The method must be declared as `public`.

The method must not be declared as `final` or `static`.

The return type must be `void`.

The method arguments must be the same as the arguments of the matching `ejbCreate<METHOD>` method.

The `throws` clause may define arbitrary application specific exceptions, including the `jakarta.ejb.CreateException`.

_Compatibility Note: Enterprise Beans 1.0 allowed the `ejbPostCreate` method to throw the `java.rmi.RemoteException` to indicate a non-application exception.
This practice was deprecated in Enterprise Beans 1.1—an Enterprise Beans 1.1 or Enterprise Beans 2.0 or later compliant enterprise bean should throw the `jakarta.ejb.EJBException` or another `java.lang.RuntimeException` to indicate non-application exceptions to the container (see <<a3221>>).
The `ejbPostCreate` method of an entity bean with cmp-version 2.x must not throw the `java.rmi.RemoteException`._

==== ejbHome<METHOD> Methods

The entity bean class may define zero or more home methods whose signatures must follow the following rules:

An `ejbHome<METHOD>` method must exist for every home `<METHOD>` method on the entity bean’s remote home or local home interface.
The method name must have `ejbHome` as its prefix followed by the name of the `<METHOD>` method in which the first character has been uppercased.

The method must be declared as `public`.

The method must not be declared as `static`.

If the `ejbHome<METHOD>` method corresponds to a home `<METHOD>` on the entity bean’s remote home interface, the method argument and return value types must be legal types for RMI-IIOP.

The `throws` clause may define arbitrary application specific exceptions.
The `throws` clause must not throw the `java.rmi.RemoteException`.

==== ejbSelect<METHOD> Methods

The entity bean class may define one or more select methods whose signatures must follow the following rules:

The method name must have `ejbSelect` as its prefix.

The method must be declared as `public`.

The method must be declared as `abstract`.

The `throws` clause must define the `jakarta.ejb.FinderException`.
The `throws` clause may define arbitrary application specific exceptions.

==== Business Methods

The entity bean class may define zero or more business methods whose signatures must follow these rules:

The method names can be arbitrary, but they must not start with '`ejb`' to avoid conflicts with the callback methods used by the Enterprise Beans architecture.

The business method must be declared as `public`.

The method must not be declared as `final` or `static`.

If the business method corresponds to a method of the entity bean’s remote interface, the method argument and return value types must be legal types for RMI-IIOP.

The `throws` clause may define arbitrary application specific exceptions.

_Compatibility Note: Enterprise Beans 1.0 allowed the business methods to throw the `java.rmi.RemoteException` to indicate a non-application exception.
This practice was deprecated in Enterprise Beans 1.1—an Enterprise Beans 1.1 or Enterprise Beans 2.0 or later compliant enterprise bean should throw the `jakarta.ejb.EJBException` or another `java.lang.RuntimeException` to indicate non-application exceptions to the container (see <<a3221>>).
The business methods of an entity bean with cmp-version 2.x must not throw the java.rmi.RemoteException._

==== Entity Bean’s Remote Interface

The following are the requirements for the entity bean’s remote interface:

The interface must extend the `jakarta.ejb.EJBObject` interface.

The methods defined in the remote interface must follow the rules for RMI-IIOP.
This means that their argument and return value types must be valid types for RMI-IIOP, and their `throws` clauses must include the `java.rmi.RemoteException`.

The remote interface is allowed to have superinterfaces.
Use of interface inheritance is subject to the RMI-IIOP rules for the definition of remote interfaces.

For each method defined in the remote interface, there must be a matching method in the entity bean’s class.
The matching method must have:

* The same name.

* The same number and types of its arguments, and the same return type.

* All the exceptions defined in the `throws` clause of the matching method of the enterprise Bean class must be defined in the `throws` clause of the method of the remote interface.

The remote interface methods must not expose local interface types, local home interface types, timer handles, or the managed collection classes that are used for entity beans with container-managed persistence as arguments or results.

==== Entity Bean’s Remote Home Interface

The following are the requirements for the entity bean’s home interface:

The interface must extend the `jakarta.ejb.EJBHome` interface.

The methods defined in this interface must follow the rules for RMI-IIOP.
This means that their argument and return types must be of valid types for RMI-IIOP, and their `throws` clauses must include the `java.rmi.RemoteException`.

The remote home interface is allowed to have superinterfaces.
Use of interface inheritance is subject to the RMI-IIOP rules for the definition of remote interfaces.

Each method defined in the remote home interface must be one of the following:

* A create method.

* A finder method.

* A home method.

Each create method must be named "```create<METHOD>```", e.g. `createLargeAccounts`.
Each create method name must match one of the `ejbCreate<METHOD>` methods defined in the enterprise bean class.
The matching `ejbCreate<METHOD>` method must have the same number and types of its arguments.
(Note that the return type is different.)

The return type for a `create<METHOD>` method must be the entity bean’s remote interface type.

All the exceptions defined in the `throws` clause of the matching `ejbCreate<METHOD>` and `ejbPostCreate<METHOD>` methods of the enterprise bean class must be included in the `throws` clause of the matching create method of the home interface (i.e., the set of exceptions defined for the create method must be a superset of the union of exceptions defined for the `ejbCreate<METHOD>` and `ejbPostCreate<METHOD>` methods).

The `throws` clause of a `create<METHOD>` method must include the `jakarta.ejb.CreateException`.

Each finder method must be named "```find<METHOD>```" (e.g. `findLargeAccounts`).

The return type for a `find<METHOD>` method must be the entity bean’s remote interface type (for a single-object finder), or a collection thereof (for a multi-object finder).

The remote home interface must always include the `findByPrimaryKey` method, which is always a single-object finder.
The method must declare the primary key class as the method argument.

The `throws` clause of a finder method must include the `jakarta.ejb.FinderException`.

Home methods can have arbitrary names, but they must not start with "```create```", "```find```", or "```remove```".
Their argument and return types must be of valid types for RMI-IIOP, and their `throws` clauses must include the `java.rmi.RemoteException`.
The matching `ejbHome` method specified in the entity bean class must have the same number and types of arguments and must return the same type as the home method as specified in the remote home interface of the bean.

The remote home interface methods must not expose local interface types, local home interface types, timers or timer handles, or the managed collection classes that are used for entity beans with container-managed persistence as arguments or results.

==== Entity Bean’s Local Interface

The following are the requirements for the entity bean’s local interface:

The interface must extend the `jakarta.ejb.EJBLocalObject` interface.

For each method defined in the local interface, there must be a matching method in the entity bean’s class.
The matching method must have:

* The same name.

* The same number and types of its arguments, and the same return type.

* All the exceptions defined in the `throws` clause of the matching method of the enterprise Bean class must be defined in the `throws` clause of the method of the local interface.

==== Entity Bean’s Local Home Interface

The following are the requirements for the entity bean’s local home interface:

The interface must extend the `jakarta.ejb.EJBLocalHome` interface.

Each method defined in the home interface must be one of the following:

* A create method.

* A finder method.

* A home method.

Each `create` method must be named "```create<METHOD>```", e.g. `createLargeAccounts`.
Each create method name must match one of the `ejbCreate<METHOD>` methods defined in the enterprise bean class.
The matching `ejbCreate<METHOD>` method must have the same number and types of its arguments. 
(Note that the return type is different.)

The return type for a `create<METHOD>` method on the local home interface must be the entity bean’s local interface type.

All the exceptions defined in the `throws` clause of the matching `ejbCreate<METHOD>` and `ejbPostCreate<METHOD>` methods of the enterprise bean class must be included in the `throws` clause of the matching create method of the local home interface (i.e., the set of exceptions defined for the `create` method must be a superset of the union of exceptions defined for the `ejbCreate<METHOD>` and `ejbPostCreate<METHOD>` methods).

The `throws` clause of a `create<METHOD>` method must include the `jakarta.ejb.CreateException`.

Each finder method must be named "```find<METHOD>```" (e.g. `findLargeAccounts`).

The return type for a `find<METHOD>` method defined on the local home interface must be the entity bean’s local interface type (for a single-object finder), or a collection thereof (for a multi-object finder).

The local home interface must always include the `findByPrimaryKey` method, which is always a single-object finder.
The method must declare the primary key class as the method argument.

The `throws` clause of a finder method must include the `jakarta.ejb.FinderException`.

Home methods can have arbitrary names, but they must not start with "```create```", "```find```", or "```remove```".
The matching `ejbHome` method specified in the entity bean class must have the same number and types of arguments and must return the same type as the home method as specified in the home interface of the bean.
The `throws` clause of a home method defined on the local home interface must not include the `java.rmi.RemoteException`.

[[a1725]]
==== Entity Bean’s Primary Key Class

The Bean Provider must specify a primary key class in the deployment descriptor.

The primary key type must be a legal Value Type in RMI-IIOP.

The class must provide suitable implementation of the `hashCode()` and `equals(Object other)` methods to simplify the management of the primary keys by the container.

==== Entity Bean’s Deployment Descriptor

The Bean Provider must specify the relationships in which the entity beans participate in the `relationships` element.

The Bean Provider must provide unique names to designate entity beans as follows, and as described in <<a1013>>.

* The Bean Provider must specify unique names for entity beans which are defined in the ejb-jar file by using the `ejb-name` element.

* The Bean Provider must specify a unique abstract schema name for an entity bean using the `abstract-schema-name` deployment descriptor element.

The Bean Provider must define a query for each finder or select method except `findByPrimaryKey(key)`.
Typically this will be provided as the content of the ejb-ql element contained in the query element for the entity bean.
The syntax of Enterprise Beans QL is defined in <<a1840>>.

Since Enterprise Beans QL query strings are embedded in the deployment descriptor, which is an XML document, it may be necessary to encode the following characters in the query string: "```>```", "```<```".

=== The Responsibilities of the Container Provider

This section describes the responsibilities of the Container Provider to support entity beans.
The Container Provider is responsible for providing the deployment tools, and for managing the entity beans at runtime, including their persistent state and relationships.

_Because the Enterprise Beans specification does not define the API between deployment tools and the container, we assume that the deployment tools described in this section are provided by the Container Provider.
Alternatively, the deployment tools may be provided by a different vendor who uses the container vendor’s specific API._

==== Generation of Implementation Classes

The deployment tools provided by the Container Provider are responsible for the generation of additional classes when the entity bean is deployed.
The tools obtain the information that they need for generation of the additional classes by introspecting the classes and interfaces provided by the Bean Provider and by examining the entity bean’s deployment descriptor.

The deployment tools must generate the following classes:

* A class that implements the entity bean’s remote home interface (i.e., the entity `EJBHome` class).

* A class that implements the entity bean’s remote interface (i.e., the entity `EJBObject` class).

* A class that implements the entity bean’s local home interface (i.e., the entity `EJBLocalHome` class).

* A class that implements the entity bean’s local interface (i.e., the `EJBLocalObject` class).

* A class that implements the entity bean class (i.e., a concrete class corresponding to the abstract entity bean class that was provided by the Bean Provider).

The deployment tools may also generate a class that mixes some container-specific code with the entity bean class.
The code may, for example, help the container to manage the entity bean instances at runtime.
Tools can use subclassing, delegation, and code generation.

The deployment tools may also allow generation of additional code that wraps the business methods and that is used to customize the business logic for an existing operational environment.
For example, a wrapper for a `debit` function on the `Account` bean may check that the debited amount does not exceed a certain limit, or perform security checking that is specific to the operational environment.

==== Enterprise Bean Class

The following are the requirements for a concrete entity bean class:

The class must extend the abstract entity bean class provided by the Bean Provider.

The class must be defined as `public` and must not be `abstract`.

The class must define a public constructor that takes no arguments.

The class must implement the get and set accessor methods of the bean’s abstract persistence schema.

The class must not define the `finalize` method.

The entity bean class must implement the `ejbFind<METHOD>` methods.

The entity bean class must implement the `ejbSelect<METHOD>` methods.

The entity bean class is allowed to implement other methods in addition to the methods required by the Enterprise Beans specification.

==== ejbFind<METHOD> Methods

For each `find<METHOD>` method in the remote home interface or local home interface of the entity bean, there must be a corresponding `ejbFind<METHOD>` method with the same argument types in the concrete entity bean class.

The method name must have `ejbFind` as its prefix.

The method must be declared as `public`.

If the `ejbFind<METHOD>` method corresponds to a `find<METHOD>` on the entity bean’s remote home interface, the method argument and return value types must be legal types for RMI-IIOP.

The return type of an `ejbFind<METHOD>` method must be the entity bean’s primary key type, or a collection of primary keys.

The `throws` clause must define the `jakarta.ejb.FinderException`.
The `throws` clause may define arbitrary application specific exceptions.

Every finder method except `ejbFindByPrimaryKey(key)` is specified in the `query` deployment descriptor element for the entity.
The container must use the Enterprise Beans QL query string that is the content of the `ejb-ql` element or the descriptive query specification contained in the `description` element as the definition of the query of the corresponding `ejbFind<METHOD>` method.

==== ejbSelect<METHOD> Methods

For each `ejbSelect<METHOD>` method in the abstract entity bean class, there must be a method with the same argument and result types in the concrete entity bean class.

Every select method is specified in a `query` deployment descriptor element for the entity.
The container must use the Enterprise Beans QL query string that is the content of the `ejb-ql` element or the descriptive query specification that is contained in the `description` element as the definition of the query of the corresponding `ejbSelect<METHOD>` method.

The container must use the contents of the `query` element, the corresponding Enterprise Beans QL string and the type of the values selected as specified by the SELECT clause to determine the type of the values returned by a select method.

The container must ensure that there are no duplicates returned by a select method if the return type is `java.util.Set`.

==== Entity EJBHome Class

The entity `EJBHome` class, which is generated by deployment tools, implements the entity bean’s remote home interface.
This class implements the methods of the `jakarta.ejb.EJBHome` interface, and the type-specific create and finder methods specific to the entity bean.

The implementation of each `create<METHOD>` method invokes a matching `ejbCreate<METHOD>` method, followed by the matching `ejbPostCreate<METHOD>` method, passing the `create<METHOD>` parameters to these matching methods.

The implementation of the remove methods defined in the `jakarta.ejb.EJBHome` interface must activate an instance (if an instance is not already in the ready state) and invoke the `ejbRemove` method on the instance.

The implementation of each `find<METHOD>` method invokes a matching `ejbFind<METHOD>` method.
The implementation of the `find<METHOD>` method must create an entity object reference for the primary key returned from the `ejbFind<METHOD>` and return the entity object reference to the client.
If the `ejbFind<METHOD>` method returns a collection of primary keys, the implementation of the `find<METHOD>` method must create a collection of entity object references for the primary keys and return the collection to the client.

The implementation of each `<METHOD>` method invokes a matching `ejbHome<METHOD>` method (in which the first character of `<METHOD>` is uppercased in the name of the `ejbHome<METHOD>` method), passing the parameters of the `<METHOD>` method to the matching `ejbHome<METHOD>` method.

==== Entity EJBObject Class

The entity `EJBObject` class, which is generated by deployment tools, implements the entity bean’s remote interface.
It implements the methods of the `jakarta.ejb.EJBObject` interface and the remote business methods specific to the entity bean.

The implementation of the `remove` method (defined in the `jakarta.ejb.EJBObject` interface) must activate an instance (if an instance is not already in the ready state) and invoke the `ejbRemove` method on the instance.

The implementation of each remote business method must activate an instance (if an instance is not already in the ready state) and invoke the matching business method on the instance.

==== Entity EJBLocalHome Class

The entity `EJBLocalHome` class, which is generated by deployment tools, implements the entity bean’s local home interface.
This class implements the methods of the `jakarta.ejb.EJBLocalHome` interface, and the type-specific create and finder methods specific to the entity bean.

The implementation of each `create<METHOD>` method invokes a matching `ejbCreate<METHOD>` method, followed by the matching `ejbPostCreate<METHOD>` method, passing the `create<METHOD>` parameters to these matching methods.

The implementation of the `remove` method defined in the `jakarta.ejb.EJBLocalHome` interface must activate an instance (if an instance is not already in the ready state) and invoke the `ejbRemove` method on the instance.

The implementation of each `find<METHOD>` method invokes a matching `ejbFind<METHOD>` method.
The implementation of the `find<METHOD>` method must create a local entity object reference for the primary key returned from the `ejbFind<METHOD>` and return the local entity object reference to the local client.
If the `ejbFind<METHOD`> method returns a collection of primary keys, the implementation of the `find<METHOD>` method must create a collection of local entity object references for the primary keys and return the collection to the local client.

The implementation of each `<METHOD>` home method invokes a matching `ejbHome<METHOD>` method (in which the first character of `<METHOD>` is uppercased in the name of the `ejbHome<METHOD>` method), passing the parameters of the `<METHOD>` method to the matching `ejbHome<METHOD>` method.

==== Entity EJBLocalObject Class

The entity `EJBLocalObject` class, which is generated by deployment tools, implements the entity bean’s local interface.
It implements the methods of the `jakarta.ejb.EJBLocalObject` interface and the local business methods specific to the entity bean.

The implementation of the `remove` method (defined in the jakarta.ejb.EJBLocalObject interface) must activate an instance (if an instance is not already in the ready state) and invoke the `ejbRemove` method on the instance.

The implementation of each local business method must activate an instance (if an instance is not already in the ready state) and invoke the matching business method on the instance.

==== Handle Class

The deployment tools are responsible for implementing the handle class for the entity bean.
The handle class must be serializable by the Java Serialization protocol.

As the handle class is not entity bean specific, the container may, but is not required to, use a single class for all deployed entity beans.

==== Home Handle Class

The deployment tools responsible for implementing the home handle class for the entity bean.
The handle class must be serializable by the Java Serialization protocol.

Because the home handle class is not entity bean specific, the container may, but is not required to, use a single class for the home handles of all deployed entity beans.

==== Metadata Class

The deployment tools are responsible for implementing the class that provides metadata information to the remote client view contract.
The class must be a valid RMI-IIOP Value Type, and must implement the `jakarta.ejb.EJBMetaData` interface.

Because the metadata class is not entity bean specific, the container may, but is not required to, use a single class for all deployed enterprise beans.

==== Instance’s Re-entrance

The container runtime must enforce the rules defined in <<a1596>>.

==== Transaction Scoping, Security, Exceptions

The container runtime must follow the rules on transaction scoping and exception handling described in <<a3185>> and <<a3210>>.
The container runtime must follow the rules on security checking described in the EJB Core Contracts and Requirements document <<a3339>> Chapter "`Security Management`".

==== Implementation of Object References

The container should implement the distribution protocol between the remote client and the container such that the object references of the remote home and remote interfaces used by entity bean clients are usable for a long period of time.
Ideally, a remote client should be able to use an object reference across a server crash and restart.
An object reference should become invalid only when the entity object has been removed, or after a reconfiguration of the server environment (for example, when the entity bean is moved to a different Enterprise Beans server or container).

_The motivation for this is to simplify the programming model for the entity bean client.
While the client code needs to have a recovery handler for the system exceptions thrown from the individual method invocations on the remote home and remote interface, the client should not be forced to re-obtain the object references._

==== EntityContext

The container must implement the `EntityContext.getEJBObject` method such that the bean instance can use the Java language cast to convert the returned value to the entity bean’s remote interface type.
Specifically, the bean instance does not have to use the `PortableRemoteObject.narrow` method for the type conversion.

[[a1820]]
=== Primary Keys

The container must be able to manipulate the primary key type of an entity bean.
Therefore, the primary key type for an entity bean with container-managed persistence must follow the rules in this subsection, in addition to those specified in <<a1725>>.

There are two ways to specify a primary key class for an entity bean with container-managed persistence:

* Primary key that maps to a single field in the entity bean class.

* Primary key that maps to multiple fields in the entity bean class.

_The second method is necessary for implementing compound keys, and the first method is convenient for single-field keys. Without the first method, simple types such as String
would have to be wrapped in a user-defined class._

==== Primary Key That Maps to a Single Field in the Entity Bean Class

The Bean Provider uses the `primkey-field` element of the deployment descriptor to specify the container-managed field of the entity bean class that contains the primary key.
The field’s type must be the primary key type.

==== Primary Key That Maps to Multiple Fields in the Entity Bean Class

The primary key class must be `public`, and must have a `public` constructor with no parameters.

All fields in the primary key class must be declared as `public`.

The names of the fields in the primary key class must be a subset of the names of the container-managed fields.
(This allows the container to extract the primary key fields from an instance’s container-managed fields, and vice versa.)

[[a1833]]
==== Special Case: Unknown Primary Key Class

In special situations, the entity Bean Provider may choose not to specify the primary key class or the primary key fields for an entity bean with container-managed persistence.
This case usually happens when the entity bean does not have a natural primary key, and/or the Bean Provider wants to allow the Deployer using the Container Provider’s tools to select the primary key fields at deployment time.
The entity bean’s primary key type will usually be derived from the primary key type used by the underlying database system that stores the entity objects.
The primary key used by the database system may not be known to the Bean Provider.

In this special case, the type of the argument of the `findByPrimaryKey` method must be declared as `java.lang.Object`.
The Bean Provider must specify the primary key class in the deployment descriptor as of the type `java.lang.Object`.

When defining the primary key for the enterprise bean, the Deployer using the Container Provider’s tools will typically add additional container-managed fields to the concrete subclass of the entity bean class (this typically happens for entity beans that do not have a natural primary key, and the primary keys are system-generated by the underlying database system that stores the
entity objects).
In this case, the container must generate the primary key value when the entity bean instance is created (and before
`ejbPostCreate` is invoked on the instance.)

_The primary key class is specified at deployment time in the situations when the Bean Provider develops an entity bean that is intended to be used with multiple back-ends that provide persistence, and when these multiple back-ends require different primary key structures._

_Use of entity beans with a deferred primary key type specification limits the client application programming model, because the clients written prior to deployment of the entity bean may not use, in general, the methods that rely on the knowledge of the primary key type._

_The implementation of the enterprise bean class methods must be done carefully.
For example, the methods should not depend on the type of the object returned from `EntityContext.getPrimaryKey`, because the return type is determined by the Deployer after the enterprise bean class has been written._
